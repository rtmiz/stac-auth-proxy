{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"stac auth proxy <p>Reverse proxy to apply auth*n to your STAC API.</p> <p> </p> <p>STAC Auth Proxy is a proxy API that mediates between the client and your internally accessible STAC API to provide flexible authentication, authorization, and content-filtering mechanisms.</p> <p>Important</p> <p>We would  to hear from you! Please join the discussion and let us know how you're using eoAPI! This helps us improve the project for you and others. If you prefer to remain anonymous, you can email us at eoapi@developmentseed.org, and we'll be happy to post a summary on your behalf.</p>"},{"location":"#features","title":"\u2728Features\u2728","text":"<ul> <li>\ud83d\udd10 Authentication: Apply OpenID Connect (OIDC) token validation and optional scope checks to specified endpoints and methods</li> <li>\ud83d\udec2 Content Filtering: Use CQL2 filters via the Filter Extension to tailor API responses based on request context (e.g. user role)</li> <li>\ud83e\udd1d External Policy Integration: Integrate with external systems (e.g. Open Policy Agent (OPA)) to generate CQL2 filters dynamically from policy decisions</li> <li>\ud83e\udde9 Authentication Extension: Add the Authentication Extension to API responses to expose auth-related metadata</li> <li>\ud83d\udcd8 OpenAPI Augmentation: Enhance the OpenAPI spec with security details to keep auto-generated docs and UIs (e.g., Swagger UI) accurate</li> <li>\ud83d\udddc\ufe0f Response Compression: Optimize response sizes using <code>starlette-cramjam</code></li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Full documentation is available on the website.</p> <p>Head to Getting Started to dig in.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0111-2026-01-13","title":"0.11.1 (2026-01-13)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add helm chart auth options. (#118) (cfae34b)</li> <li>Add helm README.md and unit tests (#117) (74a1bc8)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Enhance type safety in middleware and utility functions (#122) (52cdd0e)</li> <li>Helm chart and app version mismatch. (#120) (7998675)</li> <li>Make docker image to run as non-root. (#116) (35e06f3)</li> <li>Skip CQL2 filter build for OPTIONS requests (#123) (6ee043e), closes #110</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>temporarily disable starlette docstrings (c4fd9e0)</li> </ul>"},{"location":"changelog/#miscellaneous-chores","title":"Miscellaneous Chores","text":"<ul> <li>release 0.11.1 (976dfab)</li> </ul>"},{"location":"changelog/#0110-2025-12-15","title":"0.11.0 (2025-12-15)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>auth: Authentication failures now return 401 instead of 403</li> <li>auth: correct HTTP status codes for authentication and authorization failures (#108) (17227e4)</li> <li>Ensure x-forwarded-port header is used in Forwarded header (#115) (78525b1)</li> </ul>"},{"location":"changelog/#0101-2025-12-03","title":"0.10.1 (2025-12-03)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>helm: Add support for initContainers. (#104) (a7ca408)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>lifespan: allow endpoints that don't support trailing slashes (2e6e24b)</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Remove unused import of 'Expr' from record-level-auth (4f86e7b)</li> </ul>"},{"location":"changelog/#0100-2025-10-14","title":"0.10.0 (2025-10-14)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>skip json middleware based on response data type (#103) (16b05c3)</li> <li>support customizing port when running as a module (9a18c49)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>config: add admonitions for more details (40444cf)</li> <li>config: cleanup formatting (8a82d3d)</li> <li>update tips to describe non-upstream URL (ebadd52)</li> </ul>"},{"location":"changelog/#092-2025-09-08","title":"0.9.2 (2025-09-08)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>improve link processing (#95) (e52b5a9)</li> <li>properly return error on invalid CQL2 filters (5c5c856)</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>enhance middleware stack documentation with detailed descriptions and execution order (06b51cb)</li> <li>update filter class path syntax (a7f5b1b)</li> </ul>"},{"location":"changelog/#091-2025-09-04","title":"0.9.1 (2025-09-04)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>openapi: remove upstream servers (#90) (b54059b), closes #74</li> </ul>"},{"location":"changelog/#090-2025-09-03","title":"0.9.0 (2025-09-03)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>make use of Server-Timing header (c894026), closes #69</li> <li>remove applied filters on response links (#67) (2b2b224), closes #64</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>middleware: enhance JSON parsing error handling (#73) (daf5d09), closes #72</li> <li>retain proxy headers when behind proxy (#88) (74780f0)</li> </ul>"},{"location":"changelog/#080-2025-08-16","title":"0.8.0 (2025-08-16)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>add <code>configure_app</code> for applying middleware to existing FastAPI applications (#85) (3c5cf69)</li> <li>add aws lambda handler (#81) (214de02)</li> <li>add configurable audiences (#83) (58d05ea)</li> <li>config: expand default endpoints (#79) (6718991)</li> </ul>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>add changelog (5710853)</li> <li>add version badges to README (d962230)</li> <li>architecture: add data filtering diagrams (48afd7e)</li> <li>build out separate documentation website (#78) (6c9b6ba)</li> <li>cicd: correct filename in deploy-mkdocs workflow (5f00eca)</li> <li>cicd: fix deploy step (5178b92)</li> <li>deployment: Add details of deploying STAC Auth Proxy (aaf3802)</li> <li>describe installation via pip (bfb9ca8)</li> <li>docker: Add OpenSearch backend stack to docker-compose (#71) (d779321)</li> <li>fix getting started link (8efe5e5)</li> <li>tips: add details about CORS configuration (#84) (fc1e217)</li> <li>user-guide: Add record-level auth section (89377c6)</li> <li>user-guide: Add route-level auth user guide (#80) (a840234)</li> <li>user-guide: create getting-started section (6ba081e)</li> <li>user-guide: fix configuration links (11a5d28)</li> <li>user-guide: fix tips file ref (2d5d2ac)</li> <li>user-guide: formatting (8ed08bc)</li> <li>user-guide: Mention row-level authorization (5fbd5df)</li> <li>user-guide: Move configuration &amp; installation to user guide (170f001)</li> <li>user-guide: Mv tips to user-guide (d829800)</li> <li>user-guide: Reword authentication to authorization (37fa12d)</li> </ul>"},{"location":"changelog/#071-2025-07-31","title":"0.7.1 (2025-07-31)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>ensure OPTIONS requests are sent upstream without auth check (#76) (855183a), closes #75</li> <li>process links w/o the prefix (#70) (8a09873)</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>update middleware descriptions (d3d3769)</li> </ul>"},{"location":"changelog/#070-2025-07-19","title":"0.7.0 (2025-07-19)","text":""},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>config: add root path GET requests to default public endpoints (#62) (59c6a97)</li> </ul>"},{"location":"changelog/#061-2025-07-18","title":"0.6.1 (2025-07-18)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>fix status check for 2xx responses (#59) (5b03cb3)</li> </ul>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>add illustration for appying filters on non-filter compliant endpoints (1a75550)</li> <li>prefer headings over nested list (447a13d)</li> </ul>"},{"location":"architecture/filtering-data/","title":"Filtering Data","text":"<p>Note</p> <p>For more information on using filters to solve authorization needs, more information can be found in the user guide.</p>"},{"location":"architecture/filtering-data/#example-request-flow-for-multi-record-endpoints","title":"Example Request Flow for multi-record endpoints","text":"<pre><code>sequenceDiagram\n    Client-&gt;&gt;Proxy: GET /collections\n    Note over Proxy: EnforceAuth checks credentials\n    Note over Proxy: BuildCql2Filter creates filter\n    Note over Proxy: ApplyCql2Filter applies filter to request\n    Proxy-&gt;&gt;STAC API: GET /collection?filter=(collection=landsat)\n    STAC API-&gt;&gt;Client: Response</code></pre>"},{"location":"architecture/filtering-data/#example-request-flow-for-single-record-endpoints","title":"Example Request Flow for single-record endpoints","text":"<p>The Filter Extension does not apply to fetching individual records. As such, we must validate the record after it is returned from the upstream API but before it is returned to the user:</p> <pre><code>sequenceDiagram\n    Client-&gt;&gt;Proxy: GET /collections/abc123\n    Note over Proxy: EnforceAuth checks credentials\n    Note over Proxy: BuildCql2Filter creates filter\n    Proxy-&gt;&gt;STAC API: GET /collection/abc123\n    Note over Proxy: ApplyCql2Filter validates the response\n    STAC API-&gt;&gt;Client: Response</code></pre>"},{"location":"architecture/middleware-stack/","title":"Middleware Stack","text":"<p>Aside from the actual communication with the upstream STAC API, the majority of the proxy's functionality occurs within a chain of middlewares. Each request passes through this chain, wherein each middleware performs a specific task. The middleware chain is ordered from last added (first to run) to first added (last to run).</p> <p>Tip</p> <p>If you want to apply just the middleware onto your existing FastAPI application, you can do this with <code>configure_app</code> rather than setting up a separate proxy application.</p> <p>Important</p> <p>The order of middleware execution is critical. For example, <code>RemoveRootPathMiddleware</code> must run before <code>EnforceAuthMiddleware</code> so that authentication decisions are made on the correct path after root path removal.</p> <ol> <li> <p><code>CompressionMiddleware</code></p> <ul> <li>Enabled if: <code>ENABLE_COMPRESSION</code> is enabled</li> <li>Handles response compression</li> <li>Reduces response size for better performance</li> </ul> </li> <li> <p><code>RemoveRootPathMiddleware</code></p> <ul> <li>Enabled if: <code>ROOT_PATH</code> is configured</li> <li>Removes the application root path from incoming requests</li> <li>Ensures requests are properly routed to upstream API</li> </ul> </li> <li> <p><code>ProcessLinksMiddleware</code></p> <ul> <li>Enabled if: <code>ROOT_PATH</code> is set or <code>UPSTREAM_URL</code> path is not <code>\"/\"</code></li> <li>Updates links in JSON responses to handle root path and upstream URL path differences</li> <li>Removes upstream URL path from links and adds root path if configured</li> </ul> </li> <li> <p><code>EnforceAuthMiddleware</code></p> <ul> <li>Enabled if: Always active (core authentication middleware)</li> <li>Handles authentication and authorization</li> <li>Configurable public/private endpoints via <code>PUBLIC_ENDPOINTS</code> and <code>PRIVATE_ENDPOINTS</code></li> <li>OIDC integration via <code>OIDC_DISCOVERY_INTERNAL_URL</code></li> <li>JWT audience validation via <code>ALLOWED_JWT_AUDIENCES</code></li> <li>Places auth token payload in request state</li> </ul> </li> <li> <p><code>AddProcessTimeHeaderMiddleware</code></p> <ul> <li>Enabled if: Always active (monitoring middleware)</li> <li>Adds processing time headers to responses</li> <li>Useful for monitoring and debugging</li> </ul> </li> <li> <p><code>Cql2BuildFilterMiddleware</code></p> <ul> <li>Enabled if: <code>ITEMS_FILTER_CLS</code> or <code>COLLECTIONS_FILTER_CLS</code> is configured</li> <li>Builds CQL2 filters based on request context/state</li> <li>Places CQL2 expression in request state</li> </ul> </li> <li> <p><code>Cql2RewriteLinksFilterMiddleware</code></p> <ul> <li>Enabled if: <code>ITEMS_FILTER_CLS</code> or <code>COLLECTIONS_FILTER_CLS</code> is configured</li> <li>Rewrites filter parameters in response links to remove applied filters</li> <li>Ensures links in responses show the original filter state</li> </ul> </li> <li> <p><code>Cql2ApplyFilterQueryStringMiddleware</code></p> <ul> <li>Enabled if: <code>ITEMS_FILTER_CLS</code> or <code>COLLECTIONS_FILTER_CLS</code> is configured</li> <li>Retrieves CQL2 expression from request state</li> <li>Augments <code>GET</code> requests with CQL2 filter by appending to querystring</li> </ul> </li> <li> <p><code>Cql2ApplyFilterBodyMiddleware</code></p> <ul> <li>Enabled if: <code>ITEMS_FILTER_CLS</code> or <code>COLLECTIONS_FILTER_CLS</code> is configured</li> <li>Retrieves CQL2 expression from request state</li> <li>Augments <code>POST</code>/<code>PUT</code>/<code>PATCH</code> requests with CQL2 filter by modifying body</li> </ul> </li> <li> <p><code>Cql2ValidateResponseBodyMiddleware</code></p> <ul> <li>Enabled if: <code>ITEMS_FILTER_CLS</code> or <code>COLLECTIONS_FILTER_CLS</code> is configured</li> <li>Retrieves CQL2 expression from request state</li> <li>Validates response against CQL2 filter for non-filterable endpoints</li> </ul> </li> <li> <p><code>OpenApiMiddleware</code></p> <ul> <li>Enabled if: <code>OPENAPI_SPEC_ENDPOINT</code> is set</li> <li>Modifies OpenAPI specification based on endpoint configuration, adding security requirements</li> <li>Configurable via <code>OPENAPI_AUTH_SCHEME_NAME</code> and <code>OPENAPI_AUTH_SCHEME_OVERRIDE</code></li> </ul> </li> <li> <p><code>AuthenticationExtensionMiddleware</code></p> <ul> <li>Enabled if: <code>ENABLE_AUTHENTICATION_EXTENSION</code> is enabled</li> <li>Adds authentication extension information to STAC responses</li> <li>Annotates links with authentication requirements based on <code>PUBLIC_ENDPOINTS</code> and <code>PRIVATE_ENDPOINTS</code></li> </ul> </li> </ol>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>The application is configurable via environment variables.</p>"},{"location":"user-guide/configuration/#core","title":"Core","text":""},{"location":"user-guide/configuration/#upstream_url","title":"<code>UPSTREAM_URL</code>","text":"<p>STAC API URL</p> <ul> <li>Type: HTTP(S) URL</li> <li>Required: Yes</li> <li>Example: <code>https://your-stac-api.com/stac</code></li> </ul>"},{"location":"user-guide/configuration/#wait_for_upstream","title":"<code>WAIT_FOR_UPSTREAM</code>","text":"<p>Wait for upstream API to become available before starting proxy</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>true</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul>"},{"location":"user-guide/configuration/#check_conformance","title":"<code>CHECK_CONFORMANCE</code>","text":"<p>Ensure upstream API conforms to required conformance classes before starting proxy</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>true</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul>"},{"location":"user-guide/configuration/#enable_compression","title":"<code>ENABLE_COMPRESSION</code>","text":"<p>Enable response compression</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>true</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul>"},{"location":"user-guide/configuration/#healthz_prefix","title":"<code>HEALTHZ_PREFIX</code>","text":"<p>Path prefix for health check endpoints</p> <ul> <li>Type: string</li> <li>Required: No, defaults to <code>/healthz</code></li> <li>Example: <code>''</code> (disabled)</li> </ul>"},{"location":"user-guide/configuration/#override_host","title":"<code>OVERRIDE_HOST</code>","text":"<p>Override the host header before forwarding requests to the upstream API.</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>true</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul> <p>Tip</p> <p>Default (<code>true</code>): Overrides the <code>Host</code> header in requests sent to the upstream API to match the upstream API origin, enabling proper <code>link</code> element construction via the <code>Forwarded</code> header.</p> <p>Disable (<code>false</code>): Preserves the original <code>Host</code> header in requests sent to the upstream API so that the upstream API can use it when generating <code>link</code> elements instead of relying on proxy headers.</p>"},{"location":"user-guide/configuration/#root_path","title":"<code>ROOT_PATH</code>","text":"<p>Path prefix for the proxy API</p> <ul> <li>Type: string</li> <li>Required: No, defaults to <code>''</code> (root path)</li> <li>Example: <code>/api/v1</code></li> </ul> <p>Note</p> <p>This is independent of the upstream API's path. The proxy will handle removing this prefix from incoming requests and adding it to outgoing links.</p>"},{"location":"user-guide/configuration/#authentication","title":"Authentication","text":""},{"location":"user-guide/configuration/#oidc_discovery_url","title":"<code>OIDC_DISCOVERY_URL</code>","text":"<p>OpenID Connect discovery document URL</p> <ul> <li>Type: HTTP(S) URL</li> <li>Required: Yes</li> <li>Example: <code>https://auth.example.com/.well-known/openid-configuration</code></li> </ul>"},{"location":"user-guide/configuration/#oidc_discovery_internal_url","title":"<code>OIDC_DISCOVERY_INTERNAL_URL</code>","text":"<p>Internal network OpenID Connect discovery document URL</p> <ul> <li>Type: HTTP(S) URL</li> <li>Required: No, defaults to the value of <code>OIDC_DISCOVERY_URL</code></li> <li>Example: <code>http://auth/.well-known/openid-configuration</code></li> </ul>"},{"location":"user-guide/configuration/#allowed_jwt_audiences","title":"<code>ALLOWED_JWT_AUDIENCES</code>","text":"<p>Unique identifier(s) of API resource server(s)</p> <ul> <li>Type: string</li> <li>Required: No</li> <li>Example: <code>https://auth.example.audience.1.net,https://auth.example.audience.2.net</code></li> </ul> <p>Note</p> <p>A comma-separated list of the intended recipient(s) of the JWT. At least one audience value must match the <code>aud</code> (audience) claim present in the incoming JWT. If unset, the API will not impose a check on the <code>aud</code> claim</p>"},{"location":"user-guide/configuration/#default_public","title":"<code>DEFAULT_PUBLIC</code>","text":"<p>Default access policy for endpoints</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>false</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul>"},{"location":"user-guide/configuration/#private_endpoints","title":"<code>PRIVATE_ENDPOINTS</code>","text":"<p>Endpoints explicitly marked as requiring authentication and possibly scopes</p> <ul> <li>Type: JSON object mapping regex patterns to HTTP methods OR tuples of an HTTP method and string representing required scopes</li> <li>Required: No, defaults to the following: <pre><code>{\n  \"^/collections$\": [\"POST\"],\n  \"^/collections/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n  \"^/collections/([^/]+)/items$\": [\"POST\"],\n  \"^/collections/([^/]+)/items/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n  \"^/collections/([^/]+)/bulk_items$\": [\"POST\"]\n}\n</code></pre></li> </ul>"},{"location":"user-guide/configuration/#public_endpoints","title":"<code>PUBLIC_ENDPOINTS</code>","text":"<p>Endpoints explicitly marked as not requiring authentication, used when <code>DEFAULT_PUBLIC == False</code></p> <ul> <li>Type: JSON object mapping regex patterns to HTTP methods</li> <li>Required: No, defaults to the following: <pre><code>{\n  \"^/$\": [\"GET\"],\n  \"^/api.html$\": [\"GET\"],\n  \"^/api$\": [\"GET\"],\n  \"^/conformance$\": [\"GET\"],\n  \"^/docs/oauth2-redirect\": [\"GET\"],\n  \"^/healthz\": [\"GET\"],\n  \"^/_mgmt/ping\": [\"GET\"],\n  \"^/_mgmt/health\": [\"GET\"]\n}\n</code></pre></li> </ul>"},{"location":"user-guide/configuration/#enable_authentication_extension","title":"<code>ENABLE_AUTHENTICATION_EXTENSION</code>","text":"<p>Enable authentication extension in STAC API responses</p> <ul> <li>Type: boolean</li> <li>Required: No, defaults to <code>true</code></li> <li>Example: <code>false</code>, <code>1</code>, <code>True</code></li> </ul>"},{"location":"user-guide/configuration/#openapi-swagger-ui","title":"OpenAPI / Swagger UI","text":""},{"location":"user-guide/configuration/#openapi_spec_endpoint","title":"<code>OPENAPI_SPEC_ENDPOINT</code>","text":"<p>Path of OpenAPI specification, used for augmenting spec response with auth configuration</p> <ul> <li>Type: string or null</li> <li>Required: No, defaults to <code>/api</code></li> <li>Example: <code>''</code> (disabled)</li> </ul>"},{"location":"user-guide/configuration/#openapi_auth_scheme_name","title":"<code>OPENAPI_AUTH_SCHEME_NAME</code>","text":"<p>Name of the auth scheme to use in the OpenAPI spec</p> <ul> <li>Type: string</li> <li>Required: No, defaults to <code>oidcAuth</code></li> <li>Example: <code>jwtAuth</code></li> </ul>"},{"location":"user-guide/configuration/#openapi_auth_scheme_override","title":"<code>OPENAPI_AUTH_SCHEME_OVERRIDE</code>","text":"<p>Override for the auth scheme in the OpenAPI spec</p> <ul> <li>Type: JSON object</li> <li>Required: No, defaults to <code>null</code> (disabled)</li> <li>Example: <pre><code>{\n  \"type\": \"http\",\n  \"scheme\": \"bearer\",\n  \"bearerFormat\": \"JWT\",\n  \"description\": \"Paste your raw JWT here. This API uses Bearer token authorization.\\n\"\n}\n</code></pre></li> </ul>"},{"location":"user-guide/configuration/#swagger_ui_endpoint","title":"<code>SWAGGER_UI_ENDPOINT</code>","text":"<p>Path of Swagger UI, used to indicate that a custom Swagger UI should be hosted, typically useful when providing accompanying <code>SWAGGER_UI_INIT_OAUTH</code> arguments</p> <ul> <li>Type: string or null</li> <li>Required: No, defaults to <code>/api.html</code></li> <li>Example: <code>''</code> (disabled)</li> </ul>"},{"location":"user-guide/configuration/#swagger_ui_init_oauth","title":"<code>SWAGGER_UI_INIT_OAUTH</code>","text":"<p>Initialization options for the Swagger UI OAuth2 configuration on custom Swagger UI</p> <ul> <li>Type: JSON object</li> <li>Required: No, defaults to <code>null</code> (disabled)</li> <li>Example: <code>{\"clientId\": \"stac-auth-proxy\", \"usePkceWithAuthorizationCodeGrant\": true}</code></li> </ul>"},{"location":"user-guide/configuration/#filtering","title":"Filtering","text":""},{"location":"user-guide/configuration/#items_filter_cls","title":"<code>ITEMS_FILTER_CLS</code>","text":"<p>CQL2 expression factor for item-level filtering</p> <ul> <li>Type: JSON object with class configuration</li> <li>Required: No, defaults to <code>null</code> (disabled)</li> <li>Example: <code>stac_auth_proxy.filters:Opa</code>, <code>stac_auth_proxy.filters:Template</code>, <code>my_package:OrganizationFilter</code></li> </ul>"},{"location":"user-guide/configuration/#items_filter_args","title":"<code>ITEMS_FILTER_ARGS</code>","text":"<p>Positional arguments for CQL2 expression factor</p> <ul> <li>Type: List of positional arguments used to initialize the class</li> <li>Required: No, defaults to <code>[]</code></li> <li>Example: <code>[\"org1\"]</code></li> </ul>"},{"location":"user-guide/configuration/#items_filter_kwargs","title":"<code>ITEMS_FILTER_KWARGS</code>","text":"<p>Keyword arguments for CQL2 expression factor</p> <ul> <li>Type: Dictionary of keyword arguments used to initialize the class</li> <li>Required: No, defaults to <code>{}</code></li> <li>Example: <code>{\"field_name\": \"properties.organization\"}</code></li> </ul>"},{"location":"user-guide/configuration/#items_filter_path","title":"<code>ITEMS_FILTER_PATH</code>","text":"<p>Regex pattern used to identify request paths that require the application of the items filter</p> <ul> <li>Type: Regex string</li> <li>Required: No, defaults to <code>^(/collections/([^/]+)/items(/[^/]+)?$|/search$)</code></li> <li>Example: <code>^(/collections/([^/]+)/items(/[^/]+)?$|/search$|/custom$)</code></li> </ul>"},{"location":"user-guide/configuration/#collections_filter_cls","title":"<code>COLLECTIONS_FILTER_CLS</code>","text":"<p>CQL2 expression factor for collection-level filtering</p> <ul> <li>Type: JSON object with class configuration</li> <li>Required: No, defaults to <code>null</code> (disabled)</li> <li>Example: <code>stac_auth_proxy.filters:Opa</code>, <code>stac_auth_proxy.filters:Template</code>, <code>my_package:OrganizationFilter</code></li> </ul>"},{"location":"user-guide/configuration/#collections_filter_args","title":"<code>COLLECTIONS_FILTER_ARGS</code>","text":"<p>Positional arguments for CQL2 expression factor</p> <ul> <li>Type: List of positional arguments used to initialize the class</li> <li>Required: No, defaults to <code>[]</code></li> <li>Example: <code>[\"org1\"]</code></li> </ul>"},{"location":"user-guide/configuration/#collections_filter_kwargs","title":"<code>COLLECTIONS_FILTER_KWARGS</code>","text":"<p>Keyword arguments for CQL2 expression factor</p> <ul> <li>Type: Dictionary of keyword arguments used to initialize the class</li> <li>Required: No, defaults to <code>{}</code></li> <li>Example: <code>{\"field_name\": \"properties.organization\"}</code></li> </ul>"},{"location":"user-guide/configuration/#collections_filter_path","title":"<code>COLLECTIONS_FILTER_PATH</code>","text":"<p>Regex pattern used to identify request paths that require the application of the collections filter</p> <ul> <li>Type: Regex string</li> <li>Required: No, defaults to <code>^/collections(/[^/]+)?$</code></li> <li>Example: <code>^.*?/collections(/[^/]+)?$</code></li> </ul>"},{"location":"user-guide/deployment/","title":"Deployment","text":""},{"location":"user-guide/deployment/#general","title":"General","text":"<p>Deploying the STAC Auth Proxy is similar to deploying any other service. In general, we recommend you mirror the architecture of your other systems.</p> <p>The core principles of deploying the STAC Auth Proxy are:</p> <ol> <li>The STAC API should not be available on the public internet</li> <li>The STAC Auth Proxy should be able to communicate with both the STAC API and the OIDC Server (namely, the discovery endpoint and JWKS endpoint)</li> </ol>"},{"location":"user-guide/deployment/#networking-considerations","title":"Networking Considerations","text":""},{"location":"user-guide/deployment/#hiding-the-stac-api","title":"Hiding the STAC API","text":"<p>The STAC API should not be directly accessible from the public internet. The STAC Auth Proxy acts as the public-facing endpoint.</p>"},{"location":"user-guide/deployment/#aws-strategy","title":"AWS Strategy","text":"<ul> <li>Place the STAC API in a private subnet</li> <li>Place the STAC Auth Proxy in a public subnet with internet access</li> <li>Use security groups to restrict access between components</li> </ul>"},{"location":"user-guide/deployment/#kubernetes-strategy","title":"Kubernetes Strategy","text":"<ul> <li>Deploy the STAC API as an internal service (ClusterIP)</li> <li>Deploy the STAC Auth Proxy with an Ingress for external access</li> <li>Use network policies to control traffic flow</li> </ul>"},{"location":"user-guide/deployment/#communicating-with-the-oidc-server","title":"Communicating with the OIDC Server","text":"<p>The STAC Auth Proxy needs to communicate with your OIDC provider for authentication. If your OIDC server is not directly available to the STAC Auth Proxy, use <code>OIDC_DISCOVERY_INTERNAL_URL</code> (the <code>OIDC_DISCOVERY_URL</code> will still be used for auth in the browser, such as the Swagger UI page).</p>"},{"location":"user-guide/deployment/#aws-lambda","title":"AWS Lambda","text":"<p>For AWS Lambda deployments, we recommend using the Mangum handler with disabled lifespan events. Such a handler is available at <code>stac_auth_proxy.lambda:handler</code>.</p> <p>Tip</p> <p>If using <code>stac_auth_proxy.lambda:handler</code>, be sure to install the <code>lambda</code> optional dependencies:</p> <pre><code>pip install stac_auth_proxy[lambda]\n</code></pre>"},{"location":"user-guide/deployment/#cdk","title":"CDK","text":"<p>If using AWS CDK, a <code>StacAuthProxy</code> Construct is made available within the <code>eoapi-cdk</code> project.</p>"},{"location":"user-guide/deployment/#docker","title":"Docker","text":"<p>The STAC Auth Proxy is available as a Docker image from the GitHub Container Registry (GHCR).</p> <pre><code># Latest version\ndocker pull ghcr.io/developmentseed/stac-auth-proxy:latest\n\n# Specific version\ndocker pull ghcr.io/developmentseed/stac-auth-proxy:v0.7.1\n</code></pre>"},{"location":"user-guide/deployment/#kubernetes","title":"Kubernetes","text":"<p>The STAC Auth Proxy can be deployed to Kubernetes via the Helm Chart available on the GitHub Container Registry (GHCR).</p>"},{"location":"user-guide/deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes 1.19+</li> <li>Helm 3.2.0+</li> </ul>"},{"location":"user-guide/deployment/#installation","title":"Installation","text":"<pre><code># Add the Helm repository\nhelm registry login ghcr.io\n\n# Install with minimal configuration\nhelm install stac-auth-proxy oci://ghcr.io/developmentseed/stac-auth-proxy/charts/stac-auth-proxy \\\n  --set env.UPSTREAM_URL=https://your-stac-api.com/stac \\\n  --set env.OIDC_DISCOVERY_URL=https://your-auth-server/.well-known/openid-configuration \\\n  --set ingress.host=stac-proxy.your-domain.com\n</code></pre>"},{"location":"user-guide/deployment/#configuration","title":"Configuration","text":"Parameter Description Required Default <code>env.UPSTREAM_URL</code> URL of the STAC API to proxy Yes - <code>env.OIDC_DISCOVERY_URL</code> OpenID Connect discovery document URL Yes - <code>env</code> Environment variables passed to the container No <code>{}</code> <code>ingress.enabled</code> Enable ingress No <code>true</code> <code>ingress.className</code> Ingress class name No <code>nginx</code> <code>ingress.host</code> Hostname for the ingress No <code>\"\"</code> <code>ingress.tls.enabled</code> Enable TLS for ingress No <code>true</code> <code>replicaCount</code> Number of replicas No <code>1</code> <p>For a complete list of values, see the values.yaml file.</p>"},{"location":"user-guide/deployment/#management","title":"Management","text":"<pre><code># Upgrade\nhelm upgrade stac-auth-proxy oci://ghcr.io/developmentseed/stac-auth-proxy/charts/stac-auth-proxy\n\n# Uninstall\nhelm uninstall stac-auth-proxy\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>STAC Auth Proxy is a reverse proxy that adds authentication and authorization to your STAC API. It sits between clients and your STAC API, validating tokens to authenticate request and applying custom authorization rules.</p>"},{"location":"user-guide/getting-started/#core-requirements","title":"Core Requirements","text":"<p>To get started with STAC Auth Proxy, you need to provide two essential pieces of information:</p>"},{"location":"user-guide/getting-started/#1-oidc-discovery-url","title":"1. OIDC Discovery URL","text":"<p>You need a valid OpenID Connect (OIDC) discovery URL that points to your identity provider's configuration. This URL typically follows the pattern:</p> <pre><code>https://your-auth-provider.com/.well-known/openid-configuration\n</code></pre> <p>Tip</p> <p>Common OIDC providers include:</p> <ul> <li>Auth0: <code>https://{tenant-id}.auth0.com/.well-known/openid-configuration</code></li> <li>AWS Cognito: <code>https://cognito-idp.{region}.amazonaws.com/{user-pool-id}/.well-known/openid-configuration</code></li> <li>Azure AD: <code>https://login.microsoftonline.com/{tenant-id}/v2.0/.well-known/openid-configuration</code></li> <li>Google: <code>https://accounts.google.com/.well-known/openid-configuration</code></li> <li>Keycloak: <code>https://{keycloak-server}/auth/realms/{realm-id}/.well-known/openid-configuration</code></li> </ul>"},{"location":"user-guide/getting-started/#2-upstream-stac-api-url","title":"2. Upstream STAC API URL","text":"<p>You need the URL to your upstream STAC API that the proxy will protect:</p> <pre><code>https://your-stac-api.com/stac\n</code></pre> <p>This should be a valid STAC API that conforms to the STAC specification.</p>"},{"location":"user-guide/getting-started/#quick-start","title":"Quick Start","text":"<p>Here's a minimal example to get you started:</p>"},{"location":"user-guide/getting-started/#using-docker","title":"Using Docker","text":"<pre><code>docker run -p 8000:8000 \\\n  -e UPSTREAM_URL=https://your-stac-api.com/stac \\\n  -e OIDC_DISCOVERY_URL=https://your-auth-provider.com/.well-known/openid-configuration \\\n  ghcr.io/developmentseed/stac-auth-proxy:latest\n</code></pre>"},{"location":"user-guide/getting-started/#using-python","title":"Using Python","text":"<ol> <li>Install the package:    <pre><code>pip install stac-auth-proxy\n</code></pre></li> <li>Set environment variables:    <pre><code>export UPSTREAM_URL=https://your-stac-api.com/stac\nexport OIDC_DISCOVERY_URL=https://your-auth-provider.com/.well-known/openid-configuration\n</code></pre></li> <li>Run the proxy:    <pre><code>python -m stac_auth_proxy\n</code></pre></li> </ol>"},{"location":"user-guide/getting-started/#using-docker-compose","title":"Using Docker Compose","text":"<p>For development and experimentation, the codebase (ie within the repository, not within the Docker or Python distributions) ships with a <code>docker-compose.yaml</code> file, allowing the proxy to be run locally alongside various supporting services: the database, the STAC API, and a Mock OIDC provider.</p>"},{"location":"user-guide/getting-started/#pgstac-backend","title":"pgSTAC Backend","text":"<p>Run the application stack with a pgSTAC backend using stac-fastapi-pgstac:</p> <pre><code>docker compose up\n</code></pre>"},{"location":"user-guide/getting-started/#opensearch-backend","title":"OpenSearch Backend","text":"<p>Run the application stack with an OpenSearch backend using stac-fastapi-elasticsearch-opensearch:</p> <pre><code>docker compose --profile os up\n</code></pre> <p>The proxy will start on <code>http://localhost:8000</code> by default.</p>"},{"location":"user-guide/getting-started/#what-happens-next","title":"What Happens Next?","text":"<p>Once the proxy starts successfully:</p> <ol> <li>Health Check: The proxy verifies your upstream STAC API is accessible</li> <li>Conformance Check: It ensures your STAC API conforms to required specifications</li> <li>OIDC Discovery: It fetches and validates your OIDC provider configuration</li> <li>Ready: The proxy is now ready to handle requests</li> </ol>"},{"location":"user-guide/getting-started/#testing-your-setup","title":"Testing Your Setup","text":"<p>You can test that your proxy is working by accessing the health endpoint:</p> <pre><code>curl http://localhost:8000/healthz\n</code></pre>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Learn about all available configuration options</li> <li>Route-Level Authentication - Configure which endpoints require authentication</li> <li>Record-Level Authentication - Set up content filtering based on user permissions</li> </ul>"},{"location":"user-guide/record-level-auth/","title":"Record-Level Authorization","text":"<p>Record-level authorization (also known as row-level authorization) provides fine-grained access control to individual STAC records (items and collections) based on user and request context. This ensures users only see data they're authorized to access, regardless of their authentication status.</p> <p>Important</p> <p>The upstream STAC API must support the STAC API Filter Extension, including the Features Filter conformance class on the Features resource (<code>/collections/{cid}/items</code>).</p>"},{"location":"user-guide/record-level-auth/#how-it-works","title":"How It Works","text":"<p>Record-level authorization is implemented through data filtering\u2014a strategy that generates CQL2 filters based on request context and applies them to outgoing requests before they reach the upstream STAC API. This approach ensures that:</p> <ul> <li>Users only see records they're authorized to access</li> <li>Unauthorized records are completely hidden from search results</li> <li>Authorization decisions are made at the database level for optimal performance</li> <li>Access control is enforced consistently across all endpoints</li> </ul> <p>For endpoints where the filter extension doesn't apply (such as single-item endpoints), the filters are used to validate response data from the upstream STAC API before the user receives the data, ensuring complete authorization coverage.</p> <p>Note</p> <p>For more information on how data filtering works, some more information can be found in the architecture section of the docs.</p>"},{"location":"user-guide/record-level-auth/#supported-operations","title":"Supported Operations","text":""},{"location":"user-guide/record-level-auth/#collection-level-filtering","title":"Collection-Level Filtering","text":"<p>The <code>COLLECTIONS_FILTER_CLS</code> applies filters to the following operations:</p> <p>Currently Supported:</p> <ul> <li><code>GET /collections</code> - Append query params with generated CQL2 query</li> <li><code>GET /collections/{collection_id}</code> - Validate response against CQL2 query</li> </ul> <p>Future Support:</p> <ul> <li><code>POST /collections/</code> - Validate body with generated CQL2 query<sup>2</sup></li> <li><code>PUT /collections/{collection_id}</code> - Fetch and validate collection with CQL2 query<sup>2</sup></li> <li><code>DELETE /collections/{collection_id}</code> - Fetch and validate collection with CQL2 query<sup>2</sup></li> </ul>"},{"location":"user-guide/record-level-auth/#item-level-filtering","title":"Item-Level Filtering","text":"<p>The <code>ITEMS_FILTER_CLS</code> applies filters to the following operations:</p> <p>Currently Supported:</p> <ul> <li><code>GET /search</code> - Append query params with generated CQL2 query</li> <li><code>POST /search</code> - Append body with generated CQL2 query</li> <li><code>GET /collections/{collection_id}/items</code> - Append query params with generated CQL2 query</li> <li><code>GET /collections/{collection_id}/items/{item_id}</code> - Validate response against CQL2 query</li> </ul> <p>Future Support:</p> <ul> <li><code>POST /collections/{collection_id}/items</code> - Validate body with generated CQL2 query<sup>1</sup></li> <li><code>PUT /collections/{collection_id}/items/{item_id}</code> - Fetch and validate item with CQL2 query<sup>1</sup></li> <li><code>DELETE /collections/{collection_id}/items/{item_id}</code> - Fetch and validate item with CQL2 query<sup>1</sup></li> <li><code>POST /collections/{collection_id}/bulk_items</code> - Validate items in body with generated CQL2 query<sup>1</sup></li> </ul>"},{"location":"user-guide/record-level-auth/#filter-contract","title":"Filter Contract","text":"<p>A filter factory implements the following contract:</p> <ul> <li>A class or function that may take initialization arguments</li> <li>Once initialized, the factory is a callable with the following behavior:</li> <li>Input: A context dictionary containing request and user information</li> <li>Output: A valid CQL2 expression (as a string or dict) that filters the data</li> </ul> <p>In Python typing syntax, it conforms to:</p> <pre><code>FilterFactory = Callable[..., Callable[[dict[str, Any]], Awaitable[str | dict[str, Any]]]]\n</code></pre>"},{"location":"user-guide/record-level-auth/#example-filter-factory","title":"Example Filter Factory","text":"<pre><code>import dataclasses\nfrom typing import Any\n\n\n@dataclasses.dataclass\nclass ExampleFilter:\n    async def __call__(self, context: dict[str, Any]) -&gt; str:\n        return \"true\"\n</code></pre> <p>Tip</p> <p>Despite being referred to as a class in the settings, a filter factory could be written as a function.</p> <p>Example</p> <pre><code>from typing import Any\n\n\ndef example_filter():\n    async def example_filter(context: dict[str, Any]) -&gt; str | dict[str, Any]:\n        return \"true\"\n    return example_filter\n</code></pre>"},{"location":"user-guide/record-level-auth/#context-structure","title":"Context Structure","text":"<p>The context contains request and user information:</p> <pre><code>{\n    \"req\": {\n        \"path\": \"/collections/landsat-8/items\",\n        \"method\": \"GET\",\n        \"query_params\": {\"limit\": \"10\"},\n        \"path_params\": {\"collection_id\": \"landsat-8\"},\n        \"headers\": {\"authorization\": \"Bearer ...\"}\n    },\n    \"payload\": {\n        \"sub\": \"user123\",\n        \"scope\": \"profile email admin\",\n        \"iss\": \"https://auth.example.com\"\n    }\n}\n</code></pre>"},{"location":"user-guide/record-level-auth/#filters-configuration","title":"Filters Configuration","text":"<p>Configure filters using environment variables:</p> <pre><code># Basic configuration\nITEMS_FILTER_CLS=stac_auth_proxy.filters:Template\nITEMS_FILTER_ARGS='[\"collection IN ('public')\"]'\n\n# With keyword arguments\nITEMS_FILTER_CLS=stac_auth_proxy.filters:Opa\nITEMS_FILTER_ARGS='[\"http://opa:8181\", \"stac/items/allow\"]'\nITEMS_FILTER_KWARGS='{\"cache_ttl\": 30.0}'\n</code></pre> <p>Environment Variables:</p> <ul> <li><code>{FILTER_TYPE}_FILTER_CLS</code>: The class path</li> <li><code>{FILTER_TYPE}_FILTER_ARGS</code>: Positional arguments (comma-separated)</li> <li><code>{FILTER_TYPE}_FILTER_KWARGS</code>: Keyword arguments (comma-separated key=value pairs)</li> </ul>"},{"location":"user-guide/record-level-auth/#built-in-filter-factorys","title":"Built-in Filter Factorys","text":""},{"location":"user-guide/record-level-auth/#template-filter","title":"Template Filter","text":"<p>Generate CQL2 expressions using the Jinja templating engine. Given the request context, the Jinja template expression should render a valid CQL2 expression (likely in <code>cql2-text</code> format).</p> <pre><code>ITEMS_FILTER_CLS=stac_auth_proxy.filters:Template\nITEMS_FILTER_ARGS='[\"{{ \\\"true\\\" if payload else \\\"(preview IS NULL) OR (preview = false)\\\" }}\"]'\n</code></pre> <p>Tip</p> <p>The Template Filter works well for situations where the filter logic does not need to change, such as simply translating a property from a JWT to a CQL2 expression.</p>"},{"location":"user-guide/record-level-auth/#opa-filter","title":"OPA Filter","text":"<p>Delegate authorization to Open Policy Agent. For each request, we call out to an OPA decision with the request context, expecting that OPA will return a valid CQL2 expression.</p> <pre><code>ITEMS_FILTER_CLS=stac_auth_proxy.filters:opa.Opa\nITEMS_FILTER_ARGS='[\"http://opa:8181\",\"stac/items_cql2\"]'\n</code></pre> <p>OPA Policy Example:</p> <pre><code>package stac\n\n# Anonymous users only see NAIP collection\ndefault collections_cql2 := \"id = 'naip'\"\n\ncollections_cql2 := \"true\" if {\n    # Authenticated users get all collections\n    input.payload.sub != null\n}\n\n# Anonymous users only see NAIP year 2021 data\ndefault items_cql2 := \"\\\"naip:year\\\" = 2021\"\n\nitems_cql2 := \"true\" if {\n    # Authenticated users get all items\n    input.payload.sub != null\n}\n</code></pre>"},{"location":"user-guide/record-level-auth/#custom-filter-factories","title":"Custom Filter Factories","text":"<p>Tip</p> <p>An example integration can be found in <code>examples/custom-integration</code>.</p>"},{"location":"user-guide/record-level-auth/#complex-filter-factory","title":"Complex Filter Factory","text":"<p>An example of a more complex filter factory where the filter is generated based on the response of an external API:</p> <pre><code>import dataclasses\nfrom typing import Any, Literal, Optional\n\nfrom httpx import AsyncClient\nfrom stac_auth_proxy.utils.cache import MemoryCache\n\n\n@dataclasses.dataclass\nclass ApprovedCollectionsFilter:\n    api_url: str\n    kind: Literal[\"item\", \"collection\"] = \"item\"\n    client: AsyncClient = dataclasses.field(init=False)\n    cache: MemoryCache = dataclasses.field(init=False)\n\n    def __post_init__(self):\n        # We keep the client in the class instance to avoid creating a new client for\n        # each request, taking advantage of the client's connection pooling.\n        self.client = AsyncClient(base_url=self.api_url)\n        self.cache = MemoryCache(ttl=30)\n\n    async def __call__(self, context: dict[str, Any]) -&gt; dict[str, Any]:\n        token = context[\"req\"][\"headers\"].get(\"authorization\")\n\n        try:\n            # Check cache for a previously generated filter\n            approved_collections = self.cache[token]\n        except KeyError:\n            # Look up approved collections from an external API\n            approved_collections = await self.lookup(token)\n            self.cache[token] = approved_collections\n\n        # Build CQL2 filter\n        return {\n            \"op\": \"a_containedby\",\n            \"args\": [\n                {\"property\": \"collection\" if self.kind == \"item\" else \"id\"},\n                approved_collections\n            ],\n        }\n\n    async def lookup(self, token: Optional[str]) -&gt; list[str]:\n        # Look up approved collections from an external API\n        headers = {\"Authorization\": f\"Bearer {token}\"} if token else {}\n        response = await self.client.get(\n            f\"/get-approved-collections\",\n            headers=headers,\n        )\n        response.raise_for_status()\n        return response.json()[\"collections\"]\n</code></pre> <p>Tip</p> <p>Filter generation runs for every relevant request. Consider memoizing external API calls to improve performance.</p> <ol> <li> <p>developmentseed/stac-auth-proxy#21 \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>developmentseed/stac-auth-proxy#22 \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/route-level-auth/","title":"Route-Level Authorization","text":"<p>Route-level authorization can provide a base layer of security for the simplest use cases. This typically looks like:</p> <ul> <li>the entire catalog being private, available only to authenticated users</li> <li>most of the catalog being public, available to anonymous or authenticated users. However, a subset of endpoints (typically the transactions extension endpoints) are only available to all or a subset of authenticated users</li> </ul>"},{"location":"user-guide/route-level-auth/#configuration-variables","title":"Configuration Variables","text":"<p>Route-level authorization is controlled by three key environment variables:</p> <ul> <li><code>DEFAULT_PUBLIC</code>: Sets the default access policy for all endpoints</li> <li><code>PUBLIC_ENDPOINTS</code>: Marks endpoints as not requiring authentication (used only when <code>DEFAULT_PUBLIC=false</code>). By default, we keep the catalog root, OpenAPI spec, Swagger UI, Swagger UI auth redirect, and the proxy health endpoint as public. Note that these are all endpoints that don't serve actual STAC data; they only acknowledge the presence of a STAC catalog. This is defined by a mapping of regex path expressions to arrays of HTTP methods.</li> <li><code>PRIVATE_ENDPOINTS</code>: Marks endpoints as requiring authentication. By default, the transactions endpoints are all marked as private. This is defined by a mapping of regex path expressions to arrays of either HTTP methods or tuples of HTTP methods and space-separated required scopes.</li> </ul> <p>Tip</p> <p>Users typically don't need to specify both <code>PRIVATE_ENDPOINTS</code> and <code>PUBLIC_ENDPOINTS</code>.</p>"},{"location":"user-guide/route-level-auth/#strategies","title":"Strategies","text":""},{"location":"user-guide/route-level-auth/#private-by-default","title":"Private by Default","text":"<p>Make the entire STAC API private, requiring authentication for all endpoints.</p> <p>Note</p> <p>This is the out-of-the-box configuration of the STAC Auth Proxy.</p> <p>Configuration</p> <pre><code># Set default policy to private\nDEFAULT_PUBLIC=false\n\n# The default public endpoints are typically sufficient. Otherwise, they can be specified.\n# PUBLIC_ENDPOINTS='{ ... }'\n</code></pre> <p>Behavior</p> <ul> <li>All endpoints require authentication by default</li> <li>Only explicitly listed endpoints in <code>PUBLIC_ENDPOINTS</code> are accessible without authentication. By default, these are endpoints that don't reveal STAC data</li> <li>Useful for internal or enterprise STAC APIs where all data should be protected</li> </ul>"},{"location":"user-guide/route-level-auth/#public-by-default-with-protected-write-operations","title":"Public by Default with Protected Write Operations","text":"<p>Make the STAC API mostly public for read operations, but require authentication for write operations (transactions extension).</p> <p>Configuration</p> <pre><code># Set default policy to public\nDEFAULT_PUBLIC=true\n\n# The default private endpoints are typically sufficient. Otherwise, they can be specified.\n# PRIVATE_ENDPOINTS='{ ... }'\n</code></pre> <p>Behavior</p> <ul> <li>Read operations (GET requests) are accessible to everyone</li> <li>Write operations require authentication</li> <li>Default configuration matches this pattern</li> <li>Ideal for public STAC catalogs where data discovery is open but modifications are restricted</li> </ul>"},{"location":"user-guide/route-level-auth/#authenticated-access-with-scope-based-authorization","title":"Authenticated Access with Scope-based Authorization","text":"<p>For a level of control beyond simple anonymous vs. authenticated status, the proxy can be configured so that path/method access requires JWTs containing particular permissions in the form of the scopes claim.</p> <p>Configuration</p> <p>For granular permissions on a public API:</p> <pre><code># Set default policy to public\nDEFAULT_PUBLIC=true\n\n# Require specific scopes for write operations\nPRIVATE_ENDPOINTS='{\n  \"^/collections$\": [[\"POST\", \"collection:create\"]],\n  \"^/collections/([^/]+)$\": [[\"PUT\", \"collection:update\"], [\"PATCH\", \"collection:update\"], [\"DELETE\", \"collection:delete\"]],\n  \"^/collections/([^/]+)/items$\": [[\"POST\", \"item:create\"]],\n  \"^/collections/([^/]+)/items/([^/]+)$\": [[\"PUT\", \"item:update\"], [\"PATCH\", \"item:update\"], [\"DELETE\", \"item:delete\"]],\n  \"^/collections/([^/]+)/bulk_items$\": [[\"POST\", \"item:create\"]]\n}'\n</code></pre> <p>For role-based permissions on a private API:</p> <pre><code># Set default policy to private\nDEFAULT_PUBLIC=false\n\n# Require specific scopes for write operations\nPRIVATE_ENDPOINTS='{\n  \"^/collections$\": [[\"POST\", \"admin\"]],\n  \"^/collections/([^/]+)$\": [[\"PUT\", \"admin\"], [\"PATCH\", \"admin\"], [\"DELETE\", \"admin\"]],\n  \"^/collections/([^/]+)/items$\": [[\"POST\", \"editor\"]],\n  \"^/collections/([^/]+)/items/([^/]+)$\": [[\"PUT\", \"editor\"], [\"PATCH\", \"editor\"], [\"DELETE\", \"editor\"]],\n  \"^/collections/([^/]+)/bulk_items$\": [[\"POST\", \"editor\"]]\n}'\n</code></pre> <p>Behavior</p> <ul> <li>Users must be authenticated AND have the required scope(s)</li> <li>Different HTTP methods can require different scopes</li> <li>Scopes are checked against the user's JWT scope claim</li> <li>Unauthorized requests receive a 401 Unauthorized response</li> </ul> <p>Tip</p> <p>Multiple scopes can be provided in a space-separated format, such as <code>[\"POST\", \"scope_a scope_b scope_c\"]</code>. These scope requirements are applied with AND logic, meaning that the incoming JWT must contain all the mentioned scopes.</p>"},{"location":"user-guide/tips/","title":"Tips","text":""},{"location":"user-guide/tips/#cors","title":"CORS","text":"<p>The STAC Auth Proxy does not modify the CORS response headers from the upstream STAC API. All CORS configuration must be handled by the upstream API.</p> <p>Because the STAC Auth Proxy introduces authentication, the upstream API\u2019s CORS settings may need adjustment to support credentials. In most cases, this means:</p> <ul> <li><code>Access-Control-Allow-Credentials</code> must be <code>true</code></li> <li><code>Access-Control-Allow-Origin</code> must not be <code>*</code><sup>1</sup></li> </ul>"},{"location":"user-guide/tips/#root-paths","title":"Root Paths","text":"<p>The proxy can be optionally served from a non-root path (e.g., <code>/api/v1</code>). Additionally, the proxy can optionally proxy requests to an upstream API served from a non-root path (e.g., <code>/stac</code>). To handle this, the proxy will:</p> <ul> <li>Remove the <code>ROOT_PATH</code> from incoming requests before forwarding to the upstream API</li> <li>Remove the proxy's prefix from all links in STAC API responses</li> <li>Add the <code>ROOT_PATH</code> prefix to all links in STAC API responses</li> <li>Update the OpenAPI specification to include the <code>ROOT_PATH</code> in the servers field</li> <li>Handle requests that don't match the <code>ROOT_PATH</code> with a 404 response</li> </ul>"},{"location":"user-guide/tips/#non-oidc-workaround","title":"Non-OIDC Workaround","text":"<p>If the upstream server utilizes RS256 JWTs but does not utilize a proper OIDC server, the proxy can be configured to work around this by setting the <code>OIDC_DISCOVERY_URL</code> to a statically-hosted OIDC discovery document that points to a valid JWKS endpoint.</p>"},{"location":"user-guide/tips/#swagger-ui-direct-jwt-input","title":"Swagger UI Direct JWT Input","text":"<p>Rather than performing the login flow, the Swagger UI can be configured to accept direct JWT as input with the the following configuration:</p> <pre><code>OPENAPI_AUTH_SCHEME_NAME=jwtAuth\nOPENAPI_AUTH_SCHEME_OVERRIDE='{\n  \"type\": \"http\",\n  \"scheme\": \"bearer\",\n  \"bearerFormat\": \"JWT\",\n  \"description\": \"Paste your raw JWT here. This API uses Bearer token authorization.\"\n}'\n</code></pre>"},{"location":"user-guide/tips/#non-proxy-configuration","title":"Non-proxy Configuration","text":"<p>While the STAC Auth Proxy is designed to work out-of-the-box as an application, it might not address every projects needs. When the need for customization arises, the codebase can instead be treated as a library of components that can be used to augment a FastAPI server.</p> <p>This may look something like the following:</p> <pre><code>from fastapi import FastAPI\nfrom stac_fastapi.api.app import StacApi\nfrom stac_auth_proxy import configure_app, Settings as StacAuthSettings\n\n# Create Auth Settings\nauth_settings = StacAuthSettings(\n  upstream_url='https://stac-server',  # Dummy value, we don't make use of this value in non-proxy mode\n  oidc_discovery_url='https://auth-server/.well-known/openid-configuration',\n)\n\n# Setup App\napp = FastAPI( ... )\n\n# Apply STAC Auth Proxy middleware\nconfigure_app(app, auth_settings)\n\n# Setup STAC API\napi = StacApi( app, ... )\n</code></pre> <p>Important</p> <p>Avoid using <code>build_lifespan()</code> when operating in non-proxy mode, as we are unable to check for the non-existent upstream API.</p> <ol> <li> <p>developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS/Errors/CORSNotSupportingCredentials \u21a9</p> </li> </ol>"},{"location":"reference/stac_auth_proxy/","title":"stac_auth_proxy","text":"<p>STAC Auth Proxy package.</p> <p>This package contains the components for the STAC authentication and proxying system. It includes FastAPI routes for handling authentication, authorization, and interaction with some internal STAC API.</p>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration settings for the STAC Auth Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_url</code> <code>HttpUrl</code> required <code>oidc_discovery_url</code> <code>HttpUrl</code> required <code>oidc_discovery_internal_url</code> <code>HttpUrl</code> required <code>allowed_jwt_audiences</code> <code>Sequence[str] | None</code> <code>None</code> <code>root_path</code> <code>str</code> <code>''</code> <code>override_host</code> <code>bool</code> <code>True</code> <code>healthz_prefix</code> <code>str</code> <code>'/healthz'</code> <code>wait_for_upstream</code> <code>bool</code> <code>True</code> <code>check_conformance</code> <code>bool</code> <code>True</code> <code>enable_compression</code> <code>bool</code> <code>True</code> <code>openapi_spec_endpoint</code> <code>str | None</code> <code>'/api'</code> <code>openapi_auth_scheme_name</code> <code>str</code> <code>'oidcAuth'</code> <code>openapi_auth_scheme_override</code> <code>dict | None</code> <code>None</code> <code>swagger_ui_endpoint</code> <code>str | None</code> <code>'/api.html'</code> <code>swagger_ui_init_oauth</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>enable_authentication_extension</code> <code>bool</code> <code>True</code> <code>default_public</code> <code>bool</code> <code>False</code> <code>public_endpoints</code> <code>dict[str, Sequence[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH']]]</code> <code>{'^/$': ['GET'], '^/api.html$': ['GET'], '^/api$': ['GET'], '^/conformance$': ['GET'], '^/docs/oauth2-redirect': ['GET'], '^/healthz': ['GET'], '^/_mgmt/ping': ['GET'], '^/_mgmt/health': ['GET']}</code> <code>private_endpoints</code> <code>dict[str, Sequence[Union[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], tuple[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], str]]]]</code> <code>{'^/collections$': ['POST'], '^/collections/([^/]+)$': ['PUT', 'PATCH', 'DELETE'], '^/collections/([^/]+)/items$': ['POST'], '^/collections/([^/]+)/items/([^/]+)$': ['PUT', 'PATCH', 'DELETE'], '^/collections/([^/]+)/bulk_items$': ['POST']}</code> <code>items_filter</code> <code>_ClassInput | None</code> <code>None</code> <code>items_filter_path</code> <code>str</code> <code>'^(/collections/([^/]+)/items(/[^/]+)?$|/search$)'</code> <code>collections_filter</code> <code>_ClassInput | None</code> <code>None</code> <code>collections_filter_path</code> <code>str</code> <code>'^/collections(/[^/]+)?$'</code> Source code in <code>src/stac_auth_proxy/config.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"Configuration settings for the STAC Auth Proxy.\"\"\"\n\n    # External URLs\n    upstream_url: HttpUrl\n    oidc_discovery_url: HttpUrl\n    oidc_discovery_internal_url: HttpUrl\n    allowed_jwt_audiences: Optional[Sequence[str]] = None\n\n    root_path: str = \"\"\n    override_host: bool = True\n    healthz_prefix: str = Field(pattern=_PREFIX_PATTERN, default=\"/healthz\")\n    wait_for_upstream: bool = True\n    check_conformance: bool = True\n    enable_compression: bool = True\n\n    # OpenAPI / Swagger UI\n    openapi_spec_endpoint: Optional[str] = Field(\n        pattern=_PREFIX_PATTERN, default=\"/api\"\n    )\n    openapi_auth_scheme_name: str = \"oidcAuth\"\n    openapi_auth_scheme_override: Optional[dict] = None\n    swagger_ui_endpoint: Optional[str] = Field(\n        pattern=_PREFIX_PATTERN, default=\"/api.html\"\n    )\n    swagger_ui_init_oauth: dict = Field(default_factory=dict)\n\n    # Auth\n    enable_authentication_extension: bool = True\n    default_public: bool = False\n    public_endpoints: EndpointMethods = {\n        r\"^/$\": [\"GET\"],\n        r\"^/api.html$\": [\"GET\"],\n        r\"^/api$\": [\"GET\"],\n        r\"^/conformance$\": [\"GET\"],\n        r\"^/docs/oauth2-redirect\": [\"GET\"],\n        r\"^/healthz\": [\"GET\"],\n        r\"^/_mgmt/ping\": [\"GET\"],\n        r\"^/_mgmt/health\": [\"GET\"],\n    }\n    private_endpoints: EndpointMethodsWithScope = {\n        # https://github.com/stac-api-extensions/collection-transaction/blob/v1.0.0-beta.1/README.md#methods\n        r\"^/collections$\": [\"POST\"],\n        r\"^/collections/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n        # https://github.com/stac-api-extensions/transaction/blob/v1.0.0-rc.3/README.md#methods\n        r\"^/collections/([^/]+)/items$\": [\"POST\"],\n        r\"^/collections/([^/]+)/items/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n        # https://stac-utils.github.io/stac-fastapi/api/stac_fastapi/extensions/third_party/bulk_transactions/#bulktransactionextension\n        r\"^/collections/([^/]+)/bulk_items$\": [\"POST\"],\n    }\n\n    # Filters\n    items_filter: Optional[_ClassInput] = None\n    items_filter_path: str = r\"^(/collections/([^/]+)/items(/[^/]+)?$|/search$)\"\n    collections_filter: Optional[_ClassInput] = None\n    collections_filter_path: str = r\"^/collections(/[^/]+)?$\"\n\n    model_config = SettingsConfigDict(\n        env_nested_delimiter=\"_\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _default_oidc_discovery_internal_url(cls, data: Any) -&gt; Any:\n        \"\"\"Set the internal OIDC discovery URL to the public URL if not set.\"\"\"\n        if not data.get(\"oidc_discovery_internal_url\"):\n            data[\"oidc_discovery_internal_url\"] = data.get(\"oidc_discovery_url\")\n        return data\n\n    @field_validator(\"allowed_jwt_audiences\", mode=\"before\")\n    @classmethod\n    def parse_audience(cls, v) -&gt; Optional[Sequence[str]]:\n        \"\"\"Parse a comma separated string list of audiences into a list.\"\"\"\n        return str2list(v)\n</code></pre>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.Settings.parse_audience","title":"<code>parse_audience(v) -&gt; Optional[Sequence[str]]</code>  <code>classmethod</code>","text":"<p>Parse a comma separated string list of audiences into a list.</p> Source code in <code>src/stac_auth_proxy/config.py</code> <pre><code>@field_validator(\"allowed_jwt_audiences\", mode=\"before\")\n@classmethod\ndef parse_audience(cls, v) -&gt; Optional[Sequence[str]]:\n    \"\"\"Parse a comma separated string list of audiences into a list.\"\"\"\n    return str2list(v)\n</code></pre>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.build_lifespan","title":"<code>build_lifespan(settings: Settings | None = None, **settings_kwargs: Any)</code>","text":"<p>Create a lifespan handler that runs startup checks.</p>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.build_lifespan--parameters","title":"Parameters","text":"<p>settings : Settings | None, optional     Pre-built settings instance. If omitted, a new one is constructed from     <code>settings_kwargs</code>. **settings_kwargs : Any     Keyword arguments used to configure the health and conformance checks if     <code>settings</code> is not provided.</p>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.build_lifespan--returns","title":"Returns","text":"<p>Callable[[FastAPI], AsyncContextManager[Any]]     A callable suitable for the <code>lifespan</code> parameter of <code>FastAPI</code>.</p> Source code in <code>src/stac_auth_proxy/lifespan.py</code> <pre><code>def build_lifespan(settings: Settings | None = None, **settings_kwargs: Any):\n    \"\"\"\n    Create a lifespan handler that runs startup checks.\n\n    Parameters\n    ----------\n    settings : Settings | None, optional\n        Pre-built settings instance. If omitted, a new one is constructed from\n        ``settings_kwargs``.\n    **settings_kwargs : Any\n        Keyword arguments used to configure the health and conformance checks if\n        ``settings`` is not provided.\n\n    Returns\n    -------\n    Callable[[FastAPI], AsyncContextManager[Any]]\n        A callable suitable for the ``lifespan`` parameter of ``FastAPI``.\n\n    \"\"\"\n    if settings is None:\n        settings = Settings(**settings_kwargs)\n\n    @asynccontextmanager\n    async def lifespan(app: \"FastAPI\"):\n        assert settings is not None  # Required for type checking\n\n        # Wait for upstream servers to become available\n        if settings.wait_for_upstream:\n            await check_server_healths(\n                settings.upstream_url, settings.oidc_discovery_internal_url\n            )\n\n        # Log all middleware connected to the app\n        logger.info(\n            \"Connected middleware:\\n%s\",\n            \"\\n\".join([f\" - {m.cls.__name__}\" for m in app.user_middleware]),\n        )\n\n        if settings.check_conformance:\n            await check_conformance(app.user_middleware, str(settings.upstream_url))\n\n        yield\n\n    return lifespan\n</code></pre>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.configure_app","title":"<code>configure_app(app: FastAPI, settings: Optional[Settings] = None, **settings_kwargs: Any) -&gt; FastAPI</code>","text":"<p>Apply routes and middleware to a FastAPI app.</p>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.configure_app--parameters","title":"Parameters","text":"<p>app : FastAPI     The FastAPI app to configure. settings : Settings | None, optional     Pre-built settings instance. If omitted, a new one is constructed from     <code>settings_kwargs</code>. **settings_kwargs : Any     Keyword arguments used to configure the health and conformance checks if     <code>settings</code> is not provided.</p> Source code in <code>src/stac_auth_proxy/app.py</code> <pre><code>def configure_app(\n    app: FastAPI,\n    settings: Optional[Settings] = None,\n    **settings_kwargs: Any,\n) -&gt; FastAPI:\n    \"\"\"\n    Apply routes and middleware to a FastAPI app.\n\n    Parameters\n    ----------\n    app : FastAPI\n        The FastAPI app to configure.\n    settings : Settings | None, optional\n        Pre-built settings instance. If omitted, a new one is constructed from\n        ``settings_kwargs``.\n    **settings_kwargs : Any\n        Keyword arguments used to configure the health and conformance checks if\n        ``settings`` is not provided.\n\n    \"\"\"\n    settings = settings or Settings(**settings_kwargs)\n\n    #\n    # Route Handlers\n    #\n\n    # If we have customized Swagger UI Init settings (e.g. a provided client_id)\n    # then we need to serve our own Swagger UI in place of the upstream's. This requires\n    # that we know the Swagger UI endpoint and the OpenAPI spec endpoint.\n    if all(\n        [\n            settings.swagger_ui_endpoint,\n            settings.openapi_spec_endpoint,\n            settings.swagger_ui_init_oauth,\n        ]\n    ):\n        app.add_route(\n            settings.swagger_ui_endpoint,\n            SwaggerUI(\n                openapi_url=settings.openapi_spec_endpoint,  # type: ignore\n                init_oauth=settings.swagger_ui_init_oauth,\n            ).route,\n            include_in_schema=False,\n        )\n\n    if settings.healthz_prefix:\n        app.include_router(\n            HealthzHandler(upstream_url=str(settings.upstream_url)).router,\n            prefix=settings.healthz_prefix,\n        )\n\n    #\n    # Middleware (order is important, last added = first to run)\n    #\n\n    if settings.enable_authentication_extension:\n        app.add_middleware(\n            AuthenticationExtensionMiddleware,\n            default_public=settings.default_public,\n            public_endpoints=settings.public_endpoints,\n            private_endpoints=settings.private_endpoints,\n            oidc_discovery_url=str(settings.oidc_discovery_url),\n        )\n\n    if settings.openapi_spec_endpoint:\n        app.add_middleware(\n            OpenApiMiddleware,\n            openapi_spec_path=settings.openapi_spec_endpoint,\n            oidc_discovery_url=str(settings.oidc_discovery_url),\n            public_endpoints=settings.public_endpoints,\n            private_endpoints=settings.private_endpoints,\n            default_public=settings.default_public,\n            root_path=settings.root_path,\n            auth_scheme_name=settings.openapi_auth_scheme_name,\n            auth_scheme_override=settings.openapi_auth_scheme_override,\n        )\n\n    if settings.items_filter or settings.collections_filter:\n        app.add_middleware(Cql2ValidateResponseBodyMiddleware)\n        app.add_middleware(Cql2ApplyFilterBodyMiddleware)\n        app.add_middleware(Cql2ApplyFilterQueryStringMiddleware)\n        app.add_middleware(Cql2RewriteLinksFilterMiddleware)\n        app.add_middleware(\n            Cql2BuildFilterMiddleware,\n            items_filter=settings.items_filter() if settings.items_filter else None,\n            collections_filter=(\n                settings.collections_filter() if settings.collections_filter else None\n            ),\n            collections_filter_path=settings.collections_filter_path,\n            items_filter_path=settings.items_filter_path,\n        )\n\n    app.add_middleware(\n        AddProcessTimeHeaderMiddleware,\n    )\n\n    app.add_middleware(\n        EnforceAuthMiddleware,\n        public_endpoints=settings.public_endpoints,\n        private_endpoints=settings.private_endpoints,\n        default_public=settings.default_public,\n        oidc_discovery_url=settings.oidc_discovery_internal_url,\n        allowed_jwt_audiences=settings.allowed_jwt_audiences,\n    )\n\n    if settings.root_path or settings.upstream_url.path != \"/\":\n        app.add_middleware(\n            ProcessLinksMiddleware,\n            upstream_url=str(settings.upstream_url),\n            root_path=settings.root_path,\n        )\n\n    if settings.root_path:\n        app.add_middleware(\n            RemoveRootPathMiddleware,\n            root_path=settings.root_path,\n        )\n\n    if settings.enable_compression:\n        app.add_middleware(\n            CompressionMiddleware,\n        )\n\n    return app\n</code></pre>"},{"location":"reference/stac_auth_proxy/#stac_auth_proxy.create_app","title":"<code>create_app(settings: Optional[Settings] = None) -&gt; FastAPI</code>","text":"<p>FastAPI Application Factory.</p> Source code in <code>src/stac_auth_proxy/app.py</code> <pre><code>def create_app(settings: Optional[Settings] = None) -&gt; FastAPI:\n    \"\"\"FastAPI Application Factory.\"\"\"\n    settings = settings or Settings()\n\n    app = FastAPI(\n        openapi_url=None,  # Disable OpenAPI schema endpoint, we want to serve upstream's schema\n        lifespan=build_lifespan(settings=settings),\n        root_path=settings.root_path,\n    )\n    if app.root_path:\n        logger.debug(\"Mounted app at %s\", app.root_path)\n\n    configure_app(app, settings)\n\n    app.add_api_route(\n        \"/{path:path}\",\n        ReverseProxyHandler(\n            upstream=str(settings.upstream_url),\n            override_host=settings.override_host,\n        ).proxy_request,\n        methods=[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\"],\n    )\n\n    return app\n</code></pre>"},{"location":"reference/stac_auth_proxy/app/","title":"stac_auth_proxy.app","text":"<p>STAC Auth Proxy API.</p> <p>This module defines the FastAPI application for the STAC Auth Proxy, which handles authentication, authorization, and proxying of requests to some internal STAC API.</p>"},{"location":"reference/stac_auth_proxy/app/#stac_auth_proxy.app.configure_app","title":"<code>configure_app(app: FastAPI, settings: Optional[Settings] = None, **settings_kwargs: Any) -&gt; FastAPI</code>","text":"<p>Apply routes and middleware to a FastAPI app.</p>"},{"location":"reference/stac_auth_proxy/app/#stac_auth_proxy.app.configure_app--parameters","title":"Parameters","text":"<p>app : FastAPI     The FastAPI app to configure. settings : Settings | None, optional     Pre-built settings instance. If omitted, a new one is constructed from     <code>settings_kwargs</code>. **settings_kwargs : Any     Keyword arguments used to configure the health and conformance checks if     <code>settings</code> is not provided.</p> Source code in <code>src/stac_auth_proxy/app.py</code> <pre><code>def configure_app(\n    app: FastAPI,\n    settings: Optional[Settings] = None,\n    **settings_kwargs: Any,\n) -&gt; FastAPI:\n    \"\"\"\n    Apply routes and middleware to a FastAPI app.\n\n    Parameters\n    ----------\n    app : FastAPI\n        The FastAPI app to configure.\n    settings : Settings | None, optional\n        Pre-built settings instance. If omitted, a new one is constructed from\n        ``settings_kwargs``.\n    **settings_kwargs : Any\n        Keyword arguments used to configure the health and conformance checks if\n        ``settings`` is not provided.\n\n    \"\"\"\n    settings = settings or Settings(**settings_kwargs)\n\n    #\n    # Route Handlers\n    #\n\n    # If we have customized Swagger UI Init settings (e.g. a provided client_id)\n    # then we need to serve our own Swagger UI in place of the upstream's. This requires\n    # that we know the Swagger UI endpoint and the OpenAPI spec endpoint.\n    if all(\n        [\n            settings.swagger_ui_endpoint,\n            settings.openapi_spec_endpoint,\n            settings.swagger_ui_init_oauth,\n        ]\n    ):\n        app.add_route(\n            settings.swagger_ui_endpoint,\n            SwaggerUI(\n                openapi_url=settings.openapi_spec_endpoint,  # type: ignore\n                init_oauth=settings.swagger_ui_init_oauth,\n            ).route,\n            include_in_schema=False,\n        )\n\n    if settings.healthz_prefix:\n        app.include_router(\n            HealthzHandler(upstream_url=str(settings.upstream_url)).router,\n            prefix=settings.healthz_prefix,\n        )\n\n    #\n    # Middleware (order is important, last added = first to run)\n    #\n\n    if settings.enable_authentication_extension:\n        app.add_middleware(\n            AuthenticationExtensionMiddleware,\n            default_public=settings.default_public,\n            public_endpoints=settings.public_endpoints,\n            private_endpoints=settings.private_endpoints,\n            oidc_discovery_url=str(settings.oidc_discovery_url),\n        )\n\n    if settings.openapi_spec_endpoint:\n        app.add_middleware(\n            OpenApiMiddleware,\n            openapi_spec_path=settings.openapi_spec_endpoint,\n            oidc_discovery_url=str(settings.oidc_discovery_url),\n            public_endpoints=settings.public_endpoints,\n            private_endpoints=settings.private_endpoints,\n            default_public=settings.default_public,\n            root_path=settings.root_path,\n            auth_scheme_name=settings.openapi_auth_scheme_name,\n            auth_scheme_override=settings.openapi_auth_scheme_override,\n        )\n\n    if settings.items_filter or settings.collections_filter:\n        app.add_middleware(Cql2ValidateResponseBodyMiddleware)\n        app.add_middleware(Cql2ApplyFilterBodyMiddleware)\n        app.add_middleware(Cql2ApplyFilterQueryStringMiddleware)\n        app.add_middleware(Cql2RewriteLinksFilterMiddleware)\n        app.add_middleware(\n            Cql2BuildFilterMiddleware,\n            items_filter=settings.items_filter() if settings.items_filter else None,\n            collections_filter=(\n                settings.collections_filter() if settings.collections_filter else None\n            ),\n            collections_filter_path=settings.collections_filter_path,\n            items_filter_path=settings.items_filter_path,\n        )\n\n    app.add_middleware(\n        AddProcessTimeHeaderMiddleware,\n    )\n\n    app.add_middleware(\n        EnforceAuthMiddleware,\n        public_endpoints=settings.public_endpoints,\n        private_endpoints=settings.private_endpoints,\n        default_public=settings.default_public,\n        oidc_discovery_url=settings.oidc_discovery_internal_url,\n        allowed_jwt_audiences=settings.allowed_jwt_audiences,\n    )\n\n    if settings.root_path or settings.upstream_url.path != \"/\":\n        app.add_middleware(\n            ProcessLinksMiddleware,\n            upstream_url=str(settings.upstream_url),\n            root_path=settings.root_path,\n        )\n\n    if settings.root_path:\n        app.add_middleware(\n            RemoveRootPathMiddleware,\n            root_path=settings.root_path,\n        )\n\n    if settings.enable_compression:\n        app.add_middleware(\n            CompressionMiddleware,\n        )\n\n    return app\n</code></pre>"},{"location":"reference/stac_auth_proxy/app/#stac_auth_proxy.app.create_app","title":"<code>create_app(settings: Optional[Settings] = None) -&gt; FastAPI</code>","text":"<p>FastAPI Application Factory.</p> Source code in <code>src/stac_auth_proxy/app.py</code> <pre><code>def create_app(settings: Optional[Settings] = None) -&gt; FastAPI:\n    \"\"\"FastAPI Application Factory.\"\"\"\n    settings = settings or Settings()\n\n    app = FastAPI(\n        openapi_url=None,  # Disable OpenAPI schema endpoint, we want to serve upstream's schema\n        lifespan=build_lifespan(settings=settings),\n        root_path=settings.root_path,\n    )\n    if app.root_path:\n        logger.debug(\"Mounted app at %s\", app.root_path)\n\n    configure_app(app, settings)\n\n    app.add_api_route(\n        \"/{path:path}\",\n        ReverseProxyHandler(\n            upstream=str(settings.upstream_url),\n            override_host=settings.override_host,\n        ).proxy_request,\n        methods=[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"OPTIONS\"],\n    )\n\n    return app\n</code></pre>"},{"location":"reference/stac_auth_proxy/config/","title":"stac_auth_proxy.config","text":"<p>Configuration for the STAC Auth Proxy.</p>"},{"location":"reference/stac_auth_proxy/config/#stac_auth_proxy.config.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration settings for the STAC Auth Proxy.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_url</code> <code>HttpUrl</code> required <code>oidc_discovery_url</code> <code>HttpUrl</code> required <code>oidc_discovery_internal_url</code> <code>HttpUrl</code> required <code>allowed_jwt_audiences</code> <code>Sequence[str] | None</code> <code>None</code> <code>root_path</code> <code>str</code> <code>''</code> <code>override_host</code> <code>bool</code> <code>True</code> <code>healthz_prefix</code> <code>str</code> <code>'/healthz'</code> <code>wait_for_upstream</code> <code>bool</code> <code>True</code> <code>check_conformance</code> <code>bool</code> <code>True</code> <code>enable_compression</code> <code>bool</code> <code>True</code> <code>openapi_spec_endpoint</code> <code>str | None</code> <code>'/api'</code> <code>openapi_auth_scheme_name</code> <code>str</code> <code>'oidcAuth'</code> <code>openapi_auth_scheme_override</code> <code>dict | None</code> <code>None</code> <code>swagger_ui_endpoint</code> <code>str | None</code> <code>'/api.html'</code> <code>swagger_ui_init_oauth</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>enable_authentication_extension</code> <code>bool</code> <code>True</code> <code>default_public</code> <code>bool</code> <code>False</code> <code>public_endpoints</code> <code>dict[str, Sequence[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH']]]</code> <code>{'^/$': ['GET'], '^/api.html$': ['GET'], '^/api$': ['GET'], '^/conformance$': ['GET'], '^/docs/oauth2-redirect': ['GET'], '^/healthz': ['GET'], '^/_mgmt/ping': ['GET'], '^/_mgmt/health': ['GET']}</code> <code>private_endpoints</code> <code>dict[str, Sequence[Union[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], tuple[Literal['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], str]]]]</code> <code>{'^/collections$': ['POST'], '^/collections/([^/]+)$': ['PUT', 'PATCH', 'DELETE'], '^/collections/([^/]+)/items$': ['POST'], '^/collections/([^/]+)/items/([^/]+)$': ['PUT', 'PATCH', 'DELETE'], '^/collections/([^/]+)/bulk_items$': ['POST']}</code> <code>items_filter</code> <code>_ClassInput | None</code> <code>None</code> <code>items_filter_path</code> <code>str</code> <code>'^(/collections/([^/]+)/items(/[^/]+)?$|/search$)'</code> <code>collections_filter</code> <code>_ClassInput | None</code> <code>None</code> <code>collections_filter_path</code> <code>str</code> <code>'^/collections(/[^/]+)?$'</code> Source code in <code>src/stac_auth_proxy/config.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"Configuration settings for the STAC Auth Proxy.\"\"\"\n\n    # External URLs\n    upstream_url: HttpUrl\n    oidc_discovery_url: HttpUrl\n    oidc_discovery_internal_url: HttpUrl\n    allowed_jwt_audiences: Optional[Sequence[str]] = None\n\n    root_path: str = \"\"\n    override_host: bool = True\n    healthz_prefix: str = Field(pattern=_PREFIX_PATTERN, default=\"/healthz\")\n    wait_for_upstream: bool = True\n    check_conformance: bool = True\n    enable_compression: bool = True\n\n    # OpenAPI / Swagger UI\n    openapi_spec_endpoint: Optional[str] = Field(\n        pattern=_PREFIX_PATTERN, default=\"/api\"\n    )\n    openapi_auth_scheme_name: str = \"oidcAuth\"\n    openapi_auth_scheme_override: Optional[dict] = None\n    swagger_ui_endpoint: Optional[str] = Field(\n        pattern=_PREFIX_PATTERN, default=\"/api.html\"\n    )\n    swagger_ui_init_oauth: dict = Field(default_factory=dict)\n\n    # Auth\n    enable_authentication_extension: bool = True\n    default_public: bool = False\n    public_endpoints: EndpointMethods = {\n        r\"^/$\": [\"GET\"],\n        r\"^/api.html$\": [\"GET\"],\n        r\"^/api$\": [\"GET\"],\n        r\"^/conformance$\": [\"GET\"],\n        r\"^/docs/oauth2-redirect\": [\"GET\"],\n        r\"^/healthz\": [\"GET\"],\n        r\"^/_mgmt/ping\": [\"GET\"],\n        r\"^/_mgmt/health\": [\"GET\"],\n    }\n    private_endpoints: EndpointMethodsWithScope = {\n        # https://github.com/stac-api-extensions/collection-transaction/blob/v1.0.0-beta.1/README.md#methods\n        r\"^/collections$\": [\"POST\"],\n        r\"^/collections/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n        # https://github.com/stac-api-extensions/transaction/blob/v1.0.0-rc.3/README.md#methods\n        r\"^/collections/([^/]+)/items$\": [\"POST\"],\n        r\"^/collections/([^/]+)/items/([^/]+)$\": [\"PUT\", \"PATCH\", \"DELETE\"],\n        # https://stac-utils.github.io/stac-fastapi/api/stac_fastapi/extensions/third_party/bulk_transactions/#bulktransactionextension\n        r\"^/collections/([^/]+)/bulk_items$\": [\"POST\"],\n    }\n\n    # Filters\n    items_filter: Optional[_ClassInput] = None\n    items_filter_path: str = r\"^(/collections/([^/]+)/items(/[^/]+)?$|/search$)\"\n    collections_filter: Optional[_ClassInput] = None\n    collections_filter_path: str = r\"^/collections(/[^/]+)?$\"\n\n    model_config = SettingsConfigDict(\n        env_nested_delimiter=\"_\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def _default_oidc_discovery_internal_url(cls, data: Any) -&gt; Any:\n        \"\"\"Set the internal OIDC discovery URL to the public URL if not set.\"\"\"\n        if not data.get(\"oidc_discovery_internal_url\"):\n            data[\"oidc_discovery_internal_url\"] = data.get(\"oidc_discovery_url\")\n        return data\n\n    @field_validator(\"allowed_jwt_audiences\", mode=\"before\")\n    @classmethod\n    def parse_audience(cls, v) -&gt; Optional[Sequence[str]]:\n        \"\"\"Parse a comma separated string list of audiences into a list.\"\"\"\n        return str2list(v)\n</code></pre>"},{"location":"reference/stac_auth_proxy/config/#stac_auth_proxy.config.Settings.parse_audience","title":"<code>parse_audience(v) -&gt; Optional[Sequence[str]]</code>  <code>classmethod</code>","text":"<p>Parse a comma separated string list of audiences into a list.</p> Source code in <code>src/stac_auth_proxy/config.py</code> <pre><code>@field_validator(\"allowed_jwt_audiences\", mode=\"before\")\n@classmethod\ndef parse_audience(cls, v) -&gt; Optional[Sequence[str]]:\n    \"\"\"Parse a comma separated string list of audiences into a list.\"\"\"\n    return str2list(v)\n</code></pre>"},{"location":"reference/stac_auth_proxy/config/#stac_auth_proxy.config.str2list","title":"<code>str2list(x: Optional[str] = None) -&gt; Optional[Sequence[str]]</code>","text":"<p>Convert string to list based on , delimiter.</p> Source code in <code>src/stac_auth_proxy/config.py</code> <pre><code>def str2list(x: Optional[str] = None) -&gt; Optional[Sequence[str]]:\n    \"\"\"Convert string to list based on , delimiter.\"\"\"\n    if x:\n        return x.replace(\" \", \"\").split(\",\")\n\n    return None\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/","title":"stac_auth_proxy.filters","text":"<p>CQL2 filter factories.</p>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Opa","title":"<code>Opa</code>  <code>dataclass</code>","text":"<p>Call Open Policy Agent (OPA) to generate CQL2 filters from request context.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> required <code>decision</code> <code>str</code> required <code>cache_key</code> <code>str</code> <code>'req.headers.authorization'</code> <code>cache_ttl</code> <code>float</code> <code>5.0</code> <p>Attributes:</p> Name Type Description <code>client</code> <code>AsyncClient</code> <code>cache</code> <code>MemoryCache</code> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>@dataclass\nclass Opa:\n    \"\"\"Call Open Policy Agent (OPA) to generate CQL2 filters from request context.\"\"\"\n\n    host: str\n    decision: str\n\n    client: httpx.AsyncClient = field(init=False)\n    cache: MemoryCache = field(init=False)\n    cache_key: str = \"req.headers.authorization\"\n    cache_ttl: float = 5.0\n\n    def __post_init__(self):\n        \"\"\"Initialize the client.\"\"\"\n        self.client = httpx.AsyncClient(base_url=self.host)\n        self.cache = MemoryCache(ttl=self.cache_ttl)\n\n    async def __call__(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Generate a CQL2 filter for the request.\"\"\"\n        token = get_value_by_path(context, self.cache_key)\n        try:\n            expr_str = self.cache[token]\n        except KeyError:\n            expr_str = await self._fetch(context)\n            self.cache[token] = expr_str\n        return expr_str\n\n    async def _fetch(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Fetch the CQL2 filter from OPA.\"\"\"\n        response = await self.client.post(\n            f\"/v1/data/{self.decision}\",\n            json={\"input\": context},\n        )\n        return response.raise_for_status().json()[\"result\"]\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Opa.__call__","title":"<code>__call__(context: dict[str, Any]) -&gt; str</code>  <code>async</code>","text":"<p>Generate a CQL2 filter for the request.</p> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>async def __call__(self, context: dict[str, Any]) -&gt; str:\n    \"\"\"Generate a CQL2 filter for the request.\"\"\"\n    token = get_value_by_path(context, self.cache_key)\n    try:\n        expr_str = self.cache[token]\n    except KeyError:\n        expr_str = await self._fetch(context)\n        self.cache[token] = expr_str\n    return expr_str\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Opa.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the client.</p> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the client.\"\"\"\n    self.client = httpx.AsyncClient(base_url=self.host)\n    self.cache = MemoryCache(ttl=self.cache_ttl)\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Template","title":"<code>Template</code>  <code>dataclass</code>","text":"<p>Generate CQL2 filter expressions via Jinja2 templating.</p> <p>Parameters:</p> Name Type Description Default <code>template_str</code> <code>str</code> required <p>Attributes:</p> Name Type Description <code>env</code> <code>Environment</code> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>@dataclass\nclass Template:\n    \"\"\"Generate CQL2 filter expressions via Jinja2 templating.\"\"\"\n\n    template_str: str\n    env: Environment = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Initialize the Jinja2 environment.\"\"\"\n        self.env = Environment(loader=BaseLoader).from_string(self.template_str)\n\n    async def __call__(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Render a CQL2 filter expression with the request and auth token.\"\"\"\n        return self.env.render(**context).strip()\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Template.__call__","title":"<code>__call__(context: dict[str, Any]) -&gt; str</code>  <code>async</code>","text":"<p>Render a CQL2 filter expression with the request and auth token.</p> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>async def __call__(self, context: dict[str, Any]) -&gt; str:\n    \"\"\"Render a CQL2 filter expression with the request and auth token.\"\"\"\n    return self.env.render(**context).strip()\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/#stac_auth_proxy.filters.Template.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the Jinja2 environment.</p> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the Jinja2 environment.\"\"\"\n    self.env = Environment(loader=BaseLoader).from_string(self.template_str)\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/opa/","title":"stac_auth_proxy.filters.opa","text":"<p>Integration with Open Policy Agent (OPA) to generate CQL2 filters for requests to a STAC API.</p>"},{"location":"reference/stac_auth_proxy/filters/opa/#stac_auth_proxy.filters.opa.Opa","title":"<code>Opa</code>  <code>dataclass</code>","text":"<p>Call Open Policy Agent (OPA) to generate CQL2 filters from request context.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> required <code>decision</code> <code>str</code> required <code>cache_key</code> <code>str</code> <code>'req.headers.authorization'</code> <code>cache_ttl</code> <code>float</code> <code>5.0</code> <p>Attributes:</p> Name Type Description <code>client</code> <code>AsyncClient</code> <code>cache</code> <code>MemoryCache</code> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>@dataclass\nclass Opa:\n    \"\"\"Call Open Policy Agent (OPA) to generate CQL2 filters from request context.\"\"\"\n\n    host: str\n    decision: str\n\n    client: httpx.AsyncClient = field(init=False)\n    cache: MemoryCache = field(init=False)\n    cache_key: str = \"req.headers.authorization\"\n    cache_ttl: float = 5.0\n\n    def __post_init__(self):\n        \"\"\"Initialize the client.\"\"\"\n        self.client = httpx.AsyncClient(base_url=self.host)\n        self.cache = MemoryCache(ttl=self.cache_ttl)\n\n    async def __call__(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Generate a CQL2 filter for the request.\"\"\"\n        token = get_value_by_path(context, self.cache_key)\n        try:\n            expr_str = self.cache[token]\n        except KeyError:\n            expr_str = await self._fetch(context)\n            self.cache[token] = expr_str\n        return expr_str\n\n    async def _fetch(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Fetch the CQL2 filter from OPA.\"\"\"\n        response = await self.client.post(\n            f\"/v1/data/{self.decision}\",\n            json={\"input\": context},\n        )\n        return response.raise_for_status().json()[\"result\"]\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/opa/#stac_auth_proxy.filters.opa.Opa.__call__","title":"<code>__call__(context: dict[str, Any]) -&gt; str</code>  <code>async</code>","text":"<p>Generate a CQL2 filter for the request.</p> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>async def __call__(self, context: dict[str, Any]) -&gt; str:\n    \"\"\"Generate a CQL2 filter for the request.\"\"\"\n    token = get_value_by_path(context, self.cache_key)\n    try:\n        expr_str = self.cache[token]\n    except KeyError:\n        expr_str = await self._fetch(context)\n        self.cache[token] = expr_str\n    return expr_str\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/opa/#stac_auth_proxy.filters.opa.Opa.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the client.</p> Source code in <code>src/stac_auth_proxy/filters/opa.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the client.\"\"\"\n    self.client = httpx.AsyncClient(base_url=self.host)\n    self.cache = MemoryCache(ttl=self.cache_ttl)\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/template/","title":"stac_auth_proxy.filters.template","text":"<p>Generate CQL2 filter expressions via Jinja2 templating.</p>"},{"location":"reference/stac_auth_proxy/filters/template/#stac_auth_proxy.filters.template.Template","title":"<code>Template</code>  <code>dataclass</code>","text":"<p>Generate CQL2 filter expressions via Jinja2 templating.</p> <p>Parameters:</p> Name Type Description Default <code>template_str</code> <code>str</code> required <p>Attributes:</p> Name Type Description <code>env</code> <code>Environment</code> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>@dataclass\nclass Template:\n    \"\"\"Generate CQL2 filter expressions via Jinja2 templating.\"\"\"\n\n    template_str: str\n    env: Environment = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Initialize the Jinja2 environment.\"\"\"\n        self.env = Environment(loader=BaseLoader).from_string(self.template_str)\n\n    async def __call__(self, context: dict[str, Any]) -&gt; str:\n        \"\"\"Render a CQL2 filter expression with the request and auth token.\"\"\"\n        return self.env.render(**context).strip()\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/template/#stac_auth_proxy.filters.template.Template.__call__","title":"<code>__call__(context: dict[str, Any]) -&gt; str</code>  <code>async</code>","text":"<p>Render a CQL2 filter expression with the request and auth token.</p> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>async def __call__(self, context: dict[str, Any]) -&gt; str:\n    \"\"\"Render a CQL2 filter expression with the request and auth token.\"\"\"\n    return self.env.render(**context).strip()\n</code></pre>"},{"location":"reference/stac_auth_proxy/filters/template/#stac_auth_proxy.filters.template.Template.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the Jinja2 environment.</p> Source code in <code>src/stac_auth_proxy/filters/template.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the Jinja2 environment.\"\"\"\n    self.env = Environment(loader=BaseLoader).from_string(self.template_str)\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/","title":"stac_auth_proxy.handlers","text":"<p>Handlers to process requests.</p>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.HealthzHandler","title":"<code>HealthzHandler</code>  <code>dataclass</code>","text":"<p>Handler for health check endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_url</code> <code>str</code> required <p>Attributes:</p> Name Type Description <code>router</code> <code>APIRouter</code> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>@dataclass\nclass HealthzHandler:\n    \"\"\"Handler for health check endpoints.\"\"\"\n\n    upstream_url: str\n    router: APIRouter = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Initialize the router.\"\"\"\n        self.router = APIRouter()\n        self.router.add_api_route(\"\", self.healthz, methods=[\"GET\"])\n        self.router.add_api_route(\"/upstream\", self.healthz_upstream, methods=[\"GET\"])\n\n    async def healthz(self):\n        \"\"\"Return health of this API.\"\"\"\n        return {\"status\": \"ok\"}\n\n    async def healthz_upstream(self):\n        \"\"\"Return health of upstream STAC API.\"\"\"\n        async with AsyncClient() as client:\n            response = await client.get(self.upstream_url)\n            response.raise_for_status()\n            return {\"status\": \"ok\", \"code\": response.status_code}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.HealthzHandler.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the router.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the router.\"\"\"\n    self.router = APIRouter()\n    self.router.add_api_route(\"\", self.healthz, methods=[\"GET\"])\n    self.router.add_api_route(\"/upstream\", self.healthz_upstream, methods=[\"GET\"])\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.HealthzHandler.healthz","title":"<code>healthz()</code>  <code>async</code>","text":"<p>Return health of this API.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>async def healthz(self):\n    \"\"\"Return health of this API.\"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.HealthzHandler.healthz_upstream","title":"<code>healthz_upstream()</code>  <code>async</code>","text":"<p>Return health of upstream STAC API.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>async def healthz_upstream(self):\n    \"\"\"Return health of upstream STAC API.\"\"\"\n    async with AsyncClient() as client:\n        response = await client.get(self.upstream_url)\n        response.raise_for_status()\n        return {\"status\": \"ok\", \"code\": response.status_code}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.ReverseProxyHandler","title":"<code>ReverseProxyHandler</code>  <code>dataclass</code>","text":"<p>Reverse proxy functionality.</p> <p>Parameters:</p> Name Type Description Default <code>upstream</code> <code>str</code> required <code>client</code> <code>AsyncClient</code> <code>None</code> <code>timeout</code> <code>Timeout</code> <code>Timeout(timeout=15.0)</code> <code>proxy_name</code> <code>str</code> <code>'stac-auth-proxy'</code> <code>override_host</code> <code>bool</code> <code>True</code> <code>legacy_forwarded_headers</code> <code>bool</code> <code>False</code> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>@dataclass\nclass ReverseProxyHandler:\n    \"\"\"Reverse proxy functionality.\"\"\"\n\n    upstream: str\n    client: httpx.AsyncClient = None\n    timeout: httpx.Timeout = field(default_factory=lambda: httpx.Timeout(timeout=15.0))\n\n    proxy_name: str = \"stac-auth-proxy\"\n    override_host: bool = True\n    legacy_forwarded_headers: bool = False\n\n    def __post_init__(self):\n        \"\"\"Initialize the HTTP client.\"\"\"\n        self.client = self.client or httpx.AsyncClient(\n            base_url=self.upstream,\n            timeout=self.timeout,\n            http2=True,\n        )\n\n    def _prepare_headers(self, request: Request) -&gt; MutableHeaders:\n        \"\"\"\n        Prepare headers for the proxied request. Construct a Forwarded header to inform\n        the upstream API about the original request context, which will allow it to\n        properly construct URLs in responses (namely, in the Links). If there are\n        existing X-Forwarded-*/Forwarded headers (typically, in situations where the\n        STAC Auth Proxy is behind a proxy like Traefik or NGINX), we use those values.\n        \"\"\"\n        headers = MutableHeaders(request.headers)\n        headers.setdefault(\"Via\", f\"1.1 {self.proxy_name}\")\n\n        proxy_client = headers.get(\n            \"X-Forwarded-For\", request.client.host if request.client else \"unknown\"\n        )\n        proxy_proto = headers.get(\"X-Forwarded-Proto\", request.url.scheme)\n        proxy_host = headers.get(\"X-Forwarded-Host\", request.url.netloc)\n        proxy_port = str(headers.get(\"X-Forwarded-Port\", request.url.port))\n        proxy_path = headers.get(\"X-Forwarded-Path\", request.base_url.path)\n\n        # NOTE: If we don't include a port, it's possible that the upstream server may\n        # mistakenly use the port from the Host header (which may be the internal port\n        # of the upstream server) when constructing URLs.\n        forwarded_host = proxy_host\n        if proxy_port:\n            forwarded_host = f\"{forwarded_host}:{proxy_port}\"\n\n        headers.setdefault(\n            \"Forwarded\",\n            f\"for={proxy_client};host={forwarded_host};proto={proxy_proto};path={proxy_path}\",\n        )\n\n        # NOTE: This is useful if the upstream API does not support the Forwarded header\n        # and there were no existing X-Forwarded-* headers on the incoming request.\n        if self.legacy_forwarded_headers:\n            headers.setdefault(\"X-Forwarded-For\", proxy_client)\n            headers.setdefault(\"X-Forwarded-Host\", proxy_host)\n            headers.setdefault(\"X-Forwarded-Path\", proxy_path)\n            headers.setdefault(\"X-Forwarded-Proto\", proxy_proto)\n            headers.setdefault(\"X-Forwarded-Port\", proxy_port)\n\n        # Set host to the upstream host\n        if self.override_host:\n            headers[\"Host\"] = self.client.base_url.netloc.decode(\"utf-8\")\n\n        return headers\n\n    async def proxy_request(self, request: Request) -&gt; Response:\n        \"\"\"Proxy a request to the upstream STAC API.\"\"\"\n        headers = self._prepare_headers(request)\n\n        # https://github.com/fastapi/fastapi/discussions/7382#discussioncomment-5136466\n        rp_req = self.client.build_request(\n            request.method,\n            url=httpx.URL(\n                path=request.url.path,\n                query=request.url.query.encode(\"utf-8\"),\n            ),\n            headers=headers,\n            content=request.stream(),\n        )\n\n        # NOTE: HTTPX adds headers, so we need to trim them before sending request\n        for h in rp_req.headers:\n            if h not in headers:\n                del rp_req.headers[h]\n\n        logger.debug(f\"Proxying request to {rp_req.url}\")\n\n        start_time = time.perf_counter()\n        rp_resp = await self.client.send(rp_req, stream=True)\n        proxy_time = time.perf_counter() - start_time\n        rp_resp.headers[\"Server-Timing\"] = build_server_timing_header(\n            rp_resp.headers.get(\"Server-Timing\"),\n            name=\"upstream\",\n            dur=proxy_time,\n            desc=\"Upstream processing time\",\n        )\n        logger.debug(\n            f\"Received response status {rp_resp.status_code!r} from {rp_req.url} in {proxy_time:.3f}s\"\n        )\n\n        # We read the content here to make use of HTTPX's decompression, ensuring we have\n        # non-compressed content for the middleware to work with.\n        content = await rp_resp.aread()\n        if rp_resp.headers.get(\"Content-Encoding\"):\n            del rp_resp.headers[\"Content-Encoding\"]\n\n        return Response(\n            content=content,\n            status_code=rp_resp.status_code,\n            headers=dict(rp_resp.headers),\n        )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.ReverseProxyHandler.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the HTTP client.</p> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the HTTP client.\"\"\"\n    self.client = self.client or httpx.AsyncClient(\n        base_url=self.upstream,\n        timeout=self.timeout,\n        http2=True,\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.ReverseProxyHandler.proxy_request","title":"<code>proxy_request(request: Request) -&gt; Response</code>  <code>async</code>","text":"<p>Proxy a request to the upstream STAC API.</p> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>async def proxy_request(self, request: Request) -&gt; Response:\n    \"\"\"Proxy a request to the upstream STAC API.\"\"\"\n    headers = self._prepare_headers(request)\n\n    # https://github.com/fastapi/fastapi/discussions/7382#discussioncomment-5136466\n    rp_req = self.client.build_request(\n        request.method,\n        url=httpx.URL(\n            path=request.url.path,\n            query=request.url.query.encode(\"utf-8\"),\n        ),\n        headers=headers,\n        content=request.stream(),\n    )\n\n    # NOTE: HTTPX adds headers, so we need to trim them before sending request\n    for h in rp_req.headers:\n        if h not in headers:\n            del rp_req.headers[h]\n\n    logger.debug(f\"Proxying request to {rp_req.url}\")\n\n    start_time = time.perf_counter()\n    rp_resp = await self.client.send(rp_req, stream=True)\n    proxy_time = time.perf_counter() - start_time\n    rp_resp.headers[\"Server-Timing\"] = build_server_timing_header(\n        rp_resp.headers.get(\"Server-Timing\"),\n        name=\"upstream\",\n        dur=proxy_time,\n        desc=\"Upstream processing time\",\n    )\n    logger.debug(\n        f\"Received response status {rp_resp.status_code!r} from {rp_req.url} in {proxy_time:.3f}s\"\n    )\n\n    # We read the content here to make use of HTTPX's decompression, ensuring we have\n    # non-compressed content for the middleware to work with.\n    content = await rp_resp.aread()\n    if rp_resp.headers.get(\"Content-Encoding\"):\n        del rp_resp.headers[\"Content-Encoding\"]\n\n    return Response(\n        content=content,\n        status_code=rp_resp.status_code,\n        headers=dict(rp_resp.headers),\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.SwaggerUI","title":"<code>SwaggerUI</code>  <code>dataclass</code>","text":"<p>Swagger UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>openapi_url</code> <code>str</code> required <code>title</code> <code>str | None</code> <code>'STAC API'</code> <code>init_oauth</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>parameters</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>oauth2_redirect_url</code> <code>str</code> <code>'/docs/oauth2-redirect'</code> Source code in <code>src/stac_auth_proxy/handlers/swagger_ui.py</code> <pre><code>@dataclass\nclass SwaggerUI:\n    \"\"\"Swagger UI handler.\"\"\"\n\n    openapi_url: str\n    title: Optional[str] = \"STAC API\"\n    init_oauth: dict = field(default_factory=dict)\n    parameters: dict = field(default_factory=dict)\n    oauth2_redirect_url: str = \"/docs/oauth2-redirect\"\n\n    async def route(self, req: Request) -&gt; HTMLResponse:\n        \"\"\"Route handler.\"\"\"\n        root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n        openapi_url = root_path + self.openapi_url\n        oauth2_redirect_url = self.oauth2_redirect_url\n        if oauth2_redirect_url:\n            oauth2_redirect_url = root_path + oauth2_redirect_url\n        return get_swagger_ui_html(\n            openapi_url=openapi_url,\n            title=f\"{self.title} - Swagger UI\",\n            oauth2_redirect_url=oauth2_redirect_url,\n            init_oauth=self.init_oauth,\n            swagger_ui_parameters=self.parameters,\n        )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/#stac_auth_proxy.handlers.SwaggerUI.route","title":"<code>route(req: Request) -&gt; HTMLResponse</code>  <code>async</code>","text":"<p>Route handler.</p> Source code in <code>src/stac_auth_proxy/handlers/swagger_ui.py</code> <pre><code>async def route(self, req: Request) -&gt; HTMLResponse:\n    \"\"\"Route handler.\"\"\"\n    root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n    openapi_url = root_path + self.openapi_url\n    oauth2_redirect_url = self.oauth2_redirect_url\n    if oauth2_redirect_url:\n        oauth2_redirect_url = root_path + oauth2_redirect_url\n    return get_swagger_ui_html(\n        openapi_url=openapi_url,\n        title=f\"{self.title} - Swagger UI\",\n        oauth2_redirect_url=oauth2_redirect_url,\n        init_oauth=self.init_oauth,\n        swagger_ui_parameters=self.parameters,\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/healthz/","title":"stac_auth_proxy.handlers.healthz","text":"<p>Health check endpoints.</p>"},{"location":"reference/stac_auth_proxy/handlers/healthz/#stac_auth_proxy.handlers.healthz.HealthzHandler","title":"<code>HealthzHandler</code>  <code>dataclass</code>","text":"<p>Handler for health check endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_url</code> <code>str</code> required <p>Attributes:</p> Name Type Description <code>router</code> <code>APIRouter</code> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>@dataclass\nclass HealthzHandler:\n    \"\"\"Handler for health check endpoints.\"\"\"\n\n    upstream_url: str\n    router: APIRouter = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Initialize the router.\"\"\"\n        self.router = APIRouter()\n        self.router.add_api_route(\"\", self.healthz, methods=[\"GET\"])\n        self.router.add_api_route(\"/upstream\", self.healthz_upstream, methods=[\"GET\"])\n\n    async def healthz(self):\n        \"\"\"Return health of this API.\"\"\"\n        return {\"status\": \"ok\"}\n\n    async def healthz_upstream(self):\n        \"\"\"Return health of upstream STAC API.\"\"\"\n        async with AsyncClient() as client:\n            response = await client.get(self.upstream_url)\n            response.raise_for_status()\n            return {\"status\": \"ok\", \"code\": response.status_code}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/healthz/#stac_auth_proxy.handlers.healthz.HealthzHandler.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the router.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the router.\"\"\"\n    self.router = APIRouter()\n    self.router.add_api_route(\"\", self.healthz, methods=[\"GET\"])\n    self.router.add_api_route(\"/upstream\", self.healthz_upstream, methods=[\"GET\"])\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/healthz/#stac_auth_proxy.handlers.healthz.HealthzHandler.healthz","title":"<code>healthz()</code>  <code>async</code>","text":"<p>Return health of this API.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>async def healthz(self):\n    \"\"\"Return health of this API.\"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/healthz/#stac_auth_proxy.handlers.healthz.HealthzHandler.healthz_upstream","title":"<code>healthz_upstream()</code>  <code>async</code>","text":"<p>Return health of upstream STAC API.</p> Source code in <code>src/stac_auth_proxy/handlers/healthz.py</code> <pre><code>async def healthz_upstream(self):\n    \"\"\"Return health of upstream STAC API.\"\"\"\n    async with AsyncClient() as client:\n        response = await client.get(self.upstream_url)\n        response.raise_for_status()\n        return {\"status\": \"ok\", \"code\": response.status_code}\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/reverse_proxy/","title":"stac_auth_proxy.handlers.reverse_proxy","text":"<p>Tooling to manage the reverse proxying of requests to an upstream STAC API.</p>"},{"location":"reference/stac_auth_proxy/handlers/reverse_proxy/#stac_auth_proxy.handlers.reverse_proxy.ReverseProxyHandler","title":"<code>ReverseProxyHandler</code>  <code>dataclass</code>","text":"<p>Reverse proxy functionality.</p> <p>Parameters:</p> Name Type Description Default <code>upstream</code> <code>str</code> required <code>client</code> <code>AsyncClient</code> <code>None</code> <code>timeout</code> <code>Timeout</code> <code>Timeout(timeout=15.0)</code> <code>proxy_name</code> <code>str</code> <code>'stac-auth-proxy'</code> <code>override_host</code> <code>bool</code> <code>True</code> <code>legacy_forwarded_headers</code> <code>bool</code> <code>False</code> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>@dataclass\nclass ReverseProxyHandler:\n    \"\"\"Reverse proxy functionality.\"\"\"\n\n    upstream: str\n    client: httpx.AsyncClient = None\n    timeout: httpx.Timeout = field(default_factory=lambda: httpx.Timeout(timeout=15.0))\n\n    proxy_name: str = \"stac-auth-proxy\"\n    override_host: bool = True\n    legacy_forwarded_headers: bool = False\n\n    def __post_init__(self):\n        \"\"\"Initialize the HTTP client.\"\"\"\n        self.client = self.client or httpx.AsyncClient(\n            base_url=self.upstream,\n            timeout=self.timeout,\n            http2=True,\n        )\n\n    def _prepare_headers(self, request: Request) -&gt; MutableHeaders:\n        \"\"\"\n        Prepare headers for the proxied request. Construct a Forwarded header to inform\n        the upstream API about the original request context, which will allow it to\n        properly construct URLs in responses (namely, in the Links). If there are\n        existing X-Forwarded-*/Forwarded headers (typically, in situations where the\n        STAC Auth Proxy is behind a proxy like Traefik or NGINX), we use those values.\n        \"\"\"\n        headers = MutableHeaders(request.headers)\n        headers.setdefault(\"Via\", f\"1.1 {self.proxy_name}\")\n\n        proxy_client = headers.get(\n            \"X-Forwarded-For\", request.client.host if request.client else \"unknown\"\n        )\n        proxy_proto = headers.get(\"X-Forwarded-Proto\", request.url.scheme)\n        proxy_host = headers.get(\"X-Forwarded-Host\", request.url.netloc)\n        proxy_port = str(headers.get(\"X-Forwarded-Port\", request.url.port))\n        proxy_path = headers.get(\"X-Forwarded-Path\", request.base_url.path)\n\n        # NOTE: If we don't include a port, it's possible that the upstream server may\n        # mistakenly use the port from the Host header (which may be the internal port\n        # of the upstream server) when constructing URLs.\n        forwarded_host = proxy_host\n        if proxy_port:\n            forwarded_host = f\"{forwarded_host}:{proxy_port}\"\n\n        headers.setdefault(\n            \"Forwarded\",\n            f\"for={proxy_client};host={forwarded_host};proto={proxy_proto};path={proxy_path}\",\n        )\n\n        # NOTE: This is useful if the upstream API does not support the Forwarded header\n        # and there were no existing X-Forwarded-* headers on the incoming request.\n        if self.legacy_forwarded_headers:\n            headers.setdefault(\"X-Forwarded-For\", proxy_client)\n            headers.setdefault(\"X-Forwarded-Host\", proxy_host)\n            headers.setdefault(\"X-Forwarded-Path\", proxy_path)\n            headers.setdefault(\"X-Forwarded-Proto\", proxy_proto)\n            headers.setdefault(\"X-Forwarded-Port\", proxy_port)\n\n        # Set host to the upstream host\n        if self.override_host:\n            headers[\"Host\"] = self.client.base_url.netloc.decode(\"utf-8\")\n\n        return headers\n\n    async def proxy_request(self, request: Request) -&gt; Response:\n        \"\"\"Proxy a request to the upstream STAC API.\"\"\"\n        headers = self._prepare_headers(request)\n\n        # https://github.com/fastapi/fastapi/discussions/7382#discussioncomment-5136466\n        rp_req = self.client.build_request(\n            request.method,\n            url=httpx.URL(\n                path=request.url.path,\n                query=request.url.query.encode(\"utf-8\"),\n            ),\n            headers=headers,\n            content=request.stream(),\n        )\n\n        # NOTE: HTTPX adds headers, so we need to trim them before sending request\n        for h in rp_req.headers:\n            if h not in headers:\n                del rp_req.headers[h]\n\n        logger.debug(f\"Proxying request to {rp_req.url}\")\n\n        start_time = time.perf_counter()\n        rp_resp = await self.client.send(rp_req, stream=True)\n        proxy_time = time.perf_counter() - start_time\n        rp_resp.headers[\"Server-Timing\"] = build_server_timing_header(\n            rp_resp.headers.get(\"Server-Timing\"),\n            name=\"upstream\",\n            dur=proxy_time,\n            desc=\"Upstream processing time\",\n        )\n        logger.debug(\n            f\"Received response status {rp_resp.status_code!r} from {rp_req.url} in {proxy_time:.3f}s\"\n        )\n\n        # We read the content here to make use of HTTPX's decompression, ensuring we have\n        # non-compressed content for the middleware to work with.\n        content = await rp_resp.aread()\n        if rp_resp.headers.get(\"Content-Encoding\"):\n            del rp_resp.headers[\"Content-Encoding\"]\n\n        return Response(\n            content=content,\n            status_code=rp_resp.status_code,\n            headers=dict(rp_resp.headers),\n        )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/reverse_proxy/#stac_auth_proxy.handlers.reverse_proxy.ReverseProxyHandler.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the HTTP client.</p> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Initialize the HTTP client.\"\"\"\n    self.client = self.client or httpx.AsyncClient(\n        base_url=self.upstream,\n        timeout=self.timeout,\n        http2=True,\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/reverse_proxy/#stac_auth_proxy.handlers.reverse_proxy.ReverseProxyHandler.proxy_request","title":"<code>proxy_request(request: Request) -&gt; Response</code>  <code>async</code>","text":"<p>Proxy a request to the upstream STAC API.</p> Source code in <code>src/stac_auth_proxy/handlers/reverse_proxy.py</code> <pre><code>async def proxy_request(self, request: Request) -&gt; Response:\n    \"\"\"Proxy a request to the upstream STAC API.\"\"\"\n    headers = self._prepare_headers(request)\n\n    # https://github.com/fastapi/fastapi/discussions/7382#discussioncomment-5136466\n    rp_req = self.client.build_request(\n        request.method,\n        url=httpx.URL(\n            path=request.url.path,\n            query=request.url.query.encode(\"utf-8\"),\n        ),\n        headers=headers,\n        content=request.stream(),\n    )\n\n    # NOTE: HTTPX adds headers, so we need to trim them before sending request\n    for h in rp_req.headers:\n        if h not in headers:\n            del rp_req.headers[h]\n\n    logger.debug(f\"Proxying request to {rp_req.url}\")\n\n    start_time = time.perf_counter()\n    rp_resp = await self.client.send(rp_req, stream=True)\n    proxy_time = time.perf_counter() - start_time\n    rp_resp.headers[\"Server-Timing\"] = build_server_timing_header(\n        rp_resp.headers.get(\"Server-Timing\"),\n        name=\"upstream\",\n        dur=proxy_time,\n        desc=\"Upstream processing time\",\n    )\n    logger.debug(\n        f\"Received response status {rp_resp.status_code!r} from {rp_req.url} in {proxy_time:.3f}s\"\n    )\n\n    # We read the content here to make use of HTTPX's decompression, ensuring we have\n    # non-compressed content for the middleware to work with.\n    content = await rp_resp.aread()\n    if rp_resp.headers.get(\"Content-Encoding\"):\n        del rp_resp.headers[\"Content-Encoding\"]\n\n    return Response(\n        content=content,\n        status_code=rp_resp.status_code,\n        headers=dict(rp_resp.headers),\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/swagger_ui/","title":"stac_auth_proxy.handlers.swagger_ui","text":"<p>In order to allow customization fo the Swagger UI's OAuth2 configuration, we support overriding the default handler. This is useful for adding custom parameters such as <code>usePkceWithAuthorizationCodeGrant</code> or <code>clientId</code>.</p> <p>See: - swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/</p>"},{"location":"reference/stac_auth_proxy/handlers/swagger_ui/#stac_auth_proxy.handlers.swagger_ui.SwaggerUI","title":"<code>SwaggerUI</code>  <code>dataclass</code>","text":"<p>Swagger UI handler.</p> <p>Parameters:</p> Name Type Description Default <code>openapi_url</code> <code>str</code> required <code>title</code> <code>str | None</code> <code>'STAC API'</code> <code>init_oauth</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>parameters</code> <code>dict</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>oauth2_redirect_url</code> <code>str</code> <code>'/docs/oauth2-redirect'</code> Source code in <code>src/stac_auth_proxy/handlers/swagger_ui.py</code> <pre><code>@dataclass\nclass SwaggerUI:\n    \"\"\"Swagger UI handler.\"\"\"\n\n    openapi_url: str\n    title: Optional[str] = \"STAC API\"\n    init_oauth: dict = field(default_factory=dict)\n    parameters: dict = field(default_factory=dict)\n    oauth2_redirect_url: str = \"/docs/oauth2-redirect\"\n\n    async def route(self, req: Request) -&gt; HTMLResponse:\n        \"\"\"Route handler.\"\"\"\n        root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n        openapi_url = root_path + self.openapi_url\n        oauth2_redirect_url = self.oauth2_redirect_url\n        if oauth2_redirect_url:\n            oauth2_redirect_url = root_path + oauth2_redirect_url\n        return get_swagger_ui_html(\n            openapi_url=openapi_url,\n            title=f\"{self.title} - Swagger UI\",\n            oauth2_redirect_url=oauth2_redirect_url,\n            init_oauth=self.init_oauth,\n            swagger_ui_parameters=self.parameters,\n        )\n</code></pre>"},{"location":"reference/stac_auth_proxy/handlers/swagger_ui/#stac_auth_proxy.handlers.swagger_ui.SwaggerUI.route","title":"<code>route(req: Request) -&gt; HTMLResponse</code>  <code>async</code>","text":"<p>Route handler.</p> Source code in <code>src/stac_auth_proxy/handlers/swagger_ui.py</code> <pre><code>async def route(self, req: Request) -&gt; HTMLResponse:\n    \"\"\"Route handler.\"\"\"\n    root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n    openapi_url = root_path + self.openapi_url\n    oauth2_redirect_url = self.oauth2_redirect_url\n    if oauth2_redirect_url:\n        oauth2_redirect_url = root_path + oauth2_redirect_url\n    return get_swagger_ui_html(\n        openapi_url=openapi_url,\n        title=f\"{self.title} - Swagger UI\",\n        oauth2_redirect_url=oauth2_redirect_url,\n        init_oauth=self.init_oauth,\n        swagger_ui_parameters=self.parameters,\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/lambda/","title":"stac_auth_proxy.lambda","text":"<p>Handler for AWS Lambda.</p>"},{"location":"reference/stac_auth_proxy/lifespan/","title":"stac_auth_proxy.lifespan","text":"<p>Reusable lifespan handler for FastAPI applications.</p>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.build_lifespan","title":"<code>build_lifespan(settings: Settings | None = None, **settings_kwargs: Any)</code>","text":"<p>Create a lifespan handler that runs startup checks.</p>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.build_lifespan--parameters","title":"Parameters","text":"<p>settings : Settings | None, optional     Pre-built settings instance. If omitted, a new one is constructed from     <code>settings_kwargs</code>. **settings_kwargs : Any     Keyword arguments used to configure the health and conformance checks if     <code>settings</code> is not provided.</p>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.build_lifespan--returns","title":"Returns","text":"<p>Callable[[FastAPI], AsyncContextManager[Any]]     A callable suitable for the <code>lifespan</code> parameter of <code>FastAPI</code>.</p> Source code in <code>src/stac_auth_proxy/lifespan.py</code> <pre><code>def build_lifespan(settings: Settings | None = None, **settings_kwargs: Any):\n    \"\"\"\n    Create a lifespan handler that runs startup checks.\n\n    Parameters\n    ----------\n    settings : Settings | None, optional\n        Pre-built settings instance. If omitted, a new one is constructed from\n        ``settings_kwargs``.\n    **settings_kwargs : Any\n        Keyword arguments used to configure the health and conformance checks if\n        ``settings`` is not provided.\n\n    Returns\n    -------\n    Callable[[FastAPI], AsyncContextManager[Any]]\n        A callable suitable for the ``lifespan`` parameter of ``FastAPI``.\n\n    \"\"\"\n    if settings is None:\n        settings = Settings(**settings_kwargs)\n\n    @asynccontextmanager\n    async def lifespan(app: \"FastAPI\"):\n        assert settings is not None  # Required for type checking\n\n        # Wait for upstream servers to become available\n        if settings.wait_for_upstream:\n            await check_server_healths(\n                settings.upstream_url, settings.oidc_discovery_internal_url\n            )\n\n        # Log all middleware connected to the app\n        logger.info(\n            \"Connected middleware:\\n%s\",\n            \"\\n\".join([f\" - {m.cls.__name__}\" for m in app.user_middleware]),\n        )\n\n        if settings.check_conformance:\n            await check_conformance(app.user_middleware, str(settings.upstream_url))\n\n        yield\n\n    return lifespan\n</code></pre>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.check_conformance","title":"<code>check_conformance(middleware_classes: list[Middleware], api_url: str, attr_name: str = '__required_conformances__', endpoint: str = '/conformance')</code>  <code>async</code>","text":"<p>Check if the upstream API supports a given conformance class.</p> Source code in <code>src/stac_auth_proxy/lifespan.py</code> <pre><code>async def check_conformance(\n    middleware_classes: list[Middleware],\n    api_url: str,\n    attr_name: str = \"__required_conformances__\",\n    endpoint: str = \"/conformance\",\n):\n    \"\"\"Check if the upstream API supports a given conformance class.\"\"\"\n    required_conformances: dict[str, list[str]] = {}\n    for middleware in middleware_classes:\n        for conformance in getattr(middleware.cls, attr_name, []):\n            required_conformances.setdefault(conformance, []).append(\n                middleware.cls.__name__\n            )\n\n    async with httpx.AsyncClient(base_url=api_url) as client:\n        response = await client.get(endpoint)\n        response.raise_for_status()\n        api_conforms_to = response.json().get(\"conformsTo\", [])\n\n    missing = [\n        req_conformance\n        for req_conformance in required_conformances.keys()\n        if not any(\n            re.match(req_conformance, conformance) for conformance in api_conforms_to\n        )\n    ]\n\n    def conformance_str(conformance: str) -&gt; str:\n        return f\" - {conformance} [{','.join(required_conformances[conformance])}]\"\n\n    if missing:\n        missing_str = [conformance_str(c) for c in missing]\n        raise RuntimeError(\n            \"\\n\".join(\n                [\n                    \"Upstream catalog is missing the following conformance classes:\",\n                    *missing_str,\n                ]\n            )\n        )\n    logger.info(\n        \"Upstream catalog conforms to the following required conformance classes: \\n%s\",\n        \"\\n\".join([conformance_str(c) for c in required_conformances]),\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.check_server_health","title":"<code>check_server_health(url: str | HttpUrl, max_retries: int = 10, retry_delay: float = 1.0, retry_delay_max: float = 5.0, timeout: float = 5.0) -&gt; None</code>  <code>async</code>","text":"<p>Wait for upstream API to become available.</p> Source code in <code>src/stac_auth_proxy/lifespan.py</code> <pre><code>async def check_server_health(\n    url: str | HttpUrl,\n    max_retries: int = 10,\n    retry_delay: float = 1.0,\n    retry_delay_max: float = 5.0,\n    timeout: float = 5.0,\n) -&gt; None:\n    \"\"\"Wait for upstream API to become available.\"\"\"\n    # Convert url to string if it's a HttpUrl\n    if isinstance(url, HttpUrl):\n        url = str(url)\n\n    async with httpx.AsyncClient(timeout=timeout, follow_redirects=True) as client:\n        for attempt in range(max_retries):\n            try:\n                response = await client.get(url)\n                response.raise_for_status()\n                logger.info(f\"Upstream API {url!r} is healthy\")\n                return\n            except httpx.ConnectError as e:\n                logger.warning(f\"Upstream health check for {url!r} failed: {e}\")\n                retry_in = min(retry_delay * (2**attempt), retry_delay_max)\n                logger.warning(\n                    f\"Upstream API {url!r} not healthy, retrying in {retry_in:.1f}s \"\n                    f\"(attempt {attempt + 1}/{max_retries})\"\n                )\n                await asyncio.sleep(retry_in)\n\n    raise RuntimeError(\n        f\"Upstream API {url!r} failed to respond after {max_retries} attempts\"\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/lifespan/#stac_auth_proxy.lifespan.check_server_healths","title":"<code>check_server_healths(*urls: str | HttpUrl) -&gt; None</code>  <code>async</code>","text":"<p>Wait for upstream APIs to become available.</p> Source code in <code>src/stac_auth_proxy/lifespan.py</code> <pre><code>async def check_server_healths(*urls: str | HttpUrl) -&gt; None:\n    \"\"\"Wait for upstream APIs to become available.\"\"\"\n    logger.info(\"Running upstream server health checks...\")\n    for url in urls:\n        await check_server_health(url)\n    logger.info(\n        \"Upstream servers are healthy:\\n%s\",\n        \"\\n\".join([f\" - {url}\" for url in urls]),\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/AddProcessTimeHeaderMiddleware/","title":"stac_auth_proxy.middleware.AddProcessTimeHeaderMiddleware","text":"<p>Middleware to add Server-Timing header with proxy processing time.</p>"},{"location":"reference/stac_auth_proxy/middleware/AddProcessTimeHeaderMiddleware/#stac_auth_proxy.middleware.AddProcessTimeHeaderMiddleware.AddProcessTimeHeaderMiddleware","title":"<code>AddProcessTimeHeaderMiddleware</code>","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Middleware to add Server-Timing header with proxy processing time.</p> Source code in <code>src/stac_auth_proxy/middleware/AddProcessTimeHeaderMiddleware.py</code> <pre><code>class AddProcessTimeHeaderMiddleware(BaseHTTPMiddleware):\n    \"\"\"Middleware to add Server-Timing header with proxy processing time.\"\"\"\n\n    async def dispatch(self, request: Request, call_next) -&gt; Response:\n        \"\"\"Add Server-Timing header with proxy processing time to the response.\"\"\"\n        start_time = time.perf_counter()\n        response = await call_next(request)\n        process_time = time.perf_counter() - start_time\n\n        # Add Server-Timing header with proxy processing time\n        response.headers[\"Server-Timing\"] = build_server_timing_header(\n            response.headers.get(\"Server-Timing\"),\n            name=\"proxy\",\n            dur=process_time,\n            desc=\"Proxy processing time\",\n        )\n\n        return response\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/AddProcessTimeHeaderMiddleware/#stac_auth_proxy.middleware.AddProcessTimeHeaderMiddleware.AddProcessTimeHeaderMiddleware.dispatch","title":"<code>dispatch(request: Request, call_next) -&gt; Response</code>  <code>async</code>","text":"<p>Add Server-Timing header with proxy processing time to the response.</p> Source code in <code>src/stac_auth_proxy/middleware/AddProcessTimeHeaderMiddleware.py</code> <pre><code>async def dispatch(self, request: Request, call_next) -&gt; Response:\n    \"\"\"Add Server-Timing header with proxy processing time to the response.\"\"\"\n    start_time = time.perf_counter()\n    response = await call_next(request)\n    process_time = time.perf_counter() - start_time\n\n    # Add Server-Timing header with proxy processing time\n    response.headers[\"Server-Timing\"] = build_server_timing_header(\n        response.headers.get(\"Server-Timing\"),\n        name=\"proxy\",\n        dur=process_time,\n        desc=\"Proxy processing time\",\n    )\n\n    return response\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware/","title":"stac_auth_proxy.middleware.AuthenticationExtensionMiddleware","text":"<p>Middleware to add auth information to item response served by upstream API.</p>"},{"location":"reference/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware/#stac_auth_proxy.middleware.AuthenticationExtensionMiddleware.AuthenticationExtensionMiddleware","title":"<code>AuthenticationExtensionMiddleware</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonResponseMiddleware</code></p> <p>Middleware to add the authentication extension to the response.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>default_public</code> <code>bool</code> required <code>private_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>public_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>oidc_discovery_url</code> <code>str</code> required <code>auth_scheme_name</code> <code>str</code> <code>'oidc'</code> <code>auth_scheme</code> <code>dict[str, Any]</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> <code>extension_url</code> <code>str</code> <code>'https://stac-extensions.github.io/authentication/v1.1.0/schema.json'</code> <code>json_content_type_expr</code> <code>str</code> <code>'application/(geo\\\\+)?json'</code> Source code in <code>src/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware.py</code> <pre><code>@dataclass\nclass AuthenticationExtensionMiddleware(JsonResponseMiddleware):\n    \"\"\"Middleware to add the authentication extension to the response.\"\"\"\n\n    app: ASGIApp\n\n    default_public: bool\n    private_endpoints: EndpointMethods\n    public_endpoints: EndpointMethods\n\n    oidc_discovery_url: str\n    auth_scheme_name: str = \"oidc\"\n    auth_scheme: dict[str, Any] = field(default_factory=dict)\n    extension_url: str = (\n        \"https://stac-extensions.github.io/authentication/v1.1.0/schema.json\"\n    )\n\n    json_content_type_expr: str = r\"application/(geo\\+)?json\"\n\n    def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n        \"\"\"Determine if the response should be transformed.\"\"\"\n        # Match STAC catalog, collection, or item URLs with a single regex\n        return (\n            all(\n                (\n                    re.match(expr, val)\n                    for expr, val in [\n                        (\n                            # catalog, collections, collection, items, item, search\n                            r\"^(/|/collections(/[^/]+(/items(/[^/]+)?)?)?|/search)$\",\n                            request.url.path,\n                        ),\n                        (\n                            self.json_content_type_expr,\n                            Headers(scope=scope).get(\"content-type\", \"\"),\n                        ),\n                    ]\n                ),\n            )\n            and 200 &lt;= scope[\"status\"] &lt; 300\n        )\n\n    def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n        \"\"\"Augment the STAC Item with auth information.\"\"\"\n        extensions = ensure_type(data, \"stac_extensions\", list)\n        if self.extension_url not in extensions:\n            extensions.append(self.extension_url)\n\n        # auth:schemes\n        # ---\n        # A property that contains all of the scheme definitions used by Assets and\n        # Links in the STAC Item or Collection.\n        # - Catalogs\n        # - Collections\n        # - Item Properties\n\n        scheme_loc = data[\"properties\"] if \"properties\" in data else data\n        schemes = ensure_type(scheme_loc, \"auth:schemes\", dict)\n        schemes[self.auth_scheme_name] = {\n            \"type\": \"openIdConnect\",\n            \"openIdConnectUrl\": self.oidc_discovery_url,\n        }\n\n        # auth:refs\n        # ---\n        # Annotate links with \"auth:refs\": [auth_scheme]\n        for link in get_links(data):\n            if \"href\" not in link:\n                logger.warning(\"Link %s has no href\", link)\n                continue\n            match = find_match(\n                path=urlparse(link[\"href\"]).path,\n                method=\"GET\",\n                private_endpoints=self.private_endpoints,\n                public_endpoints=self.public_endpoints,\n                default_public=self.default_public,\n            )\n            if match.is_private:\n                auth_refs = ensure_type(link, \"auth:refs\", list)\n                auth_refs.append(self.auth_scheme_name)\n\n        return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware/#stac_auth_proxy.middleware.AuthenticationExtensionMiddleware.AuthenticationExtensionMiddleware.should_transform_response","title":"<code>should_transform_response(request: Request, scope: Scope) -&gt; bool</code>","text":"<p>Determine if the response should be transformed.</p> Source code in <code>src/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware.py</code> <pre><code>def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n    \"\"\"Determine if the response should be transformed.\"\"\"\n    # Match STAC catalog, collection, or item URLs with a single regex\n    return (\n        all(\n            (\n                re.match(expr, val)\n                for expr, val in [\n                    (\n                        # catalog, collections, collection, items, item, search\n                        r\"^(/|/collections(/[^/]+(/items(/[^/]+)?)?)?|/search)$\",\n                        request.url.path,\n                    ),\n                    (\n                        self.json_content_type_expr,\n                        Headers(scope=scope).get(\"content-type\", \"\"),\n                    ),\n                ]\n            ),\n        )\n        and 200 &lt;= scope[\"status\"] &lt; 300\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware/#stac_auth_proxy.middleware.AuthenticationExtensionMiddleware.AuthenticationExtensionMiddleware.transform_json","title":"<code>transform_json(data: dict[str, Any], request: Request) -&gt; dict[str, Any]</code>","text":"<p>Augment the STAC Item with auth information.</p> Source code in <code>src/stac_auth_proxy/middleware/AuthenticationExtensionMiddleware.py</code> <pre><code>def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n    \"\"\"Augment the STAC Item with auth information.\"\"\"\n    extensions = ensure_type(data, \"stac_extensions\", list)\n    if self.extension_url not in extensions:\n        extensions.append(self.extension_url)\n\n    # auth:schemes\n    # ---\n    # A property that contains all of the scheme definitions used by Assets and\n    # Links in the STAC Item or Collection.\n    # - Catalogs\n    # - Collections\n    # - Item Properties\n\n    scheme_loc = data[\"properties\"] if \"properties\" in data else data\n    schemes = ensure_type(scheme_loc, \"auth:schemes\", dict)\n    schemes[self.auth_scheme_name] = {\n        \"type\": \"openIdConnect\",\n        \"openIdConnectUrl\": self.oidc_discovery_url,\n    }\n\n    # auth:refs\n    # ---\n    # Annotate links with \"auth:refs\": [auth_scheme]\n    for link in get_links(data):\n        if \"href\" not in link:\n            logger.warning(\"Link %s has no href\", link)\n            continue\n        match = find_match(\n            path=urlparse(link[\"href\"]).path,\n            method=\"GET\",\n            private_endpoints=self.private_endpoints,\n            public_endpoints=self.public_endpoints,\n            default_public=self.default_public,\n        )\n        if match.is_private:\n            auth_refs = ensure_type(link, \"auth:refs\", list)\n            auth_refs.append(self.auth_scheme_name)\n\n    return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterBodyMiddleware/","title":"stac_auth_proxy.middleware.Cql2ApplyFilterBodyMiddleware","text":"<p>Middleware to augment the request body with a CQL2 filter for POST/PUT/PATCH requests.</p>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterBodyMiddleware/#stac_auth_proxy.middleware.Cql2ApplyFilterBodyMiddleware.Cql2ApplyFilterBodyMiddleware","title":"<code>Cql2ApplyFilterBodyMiddleware</code>  <code>dataclass</code>","text":"<p>Middleware to augment the request body with a CQL2 filter for POST/PUT/PATCH requests.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>state_key</code> <code>str</code> <code>'cql2_filter'</code> Source code in <code>src/stac_auth_proxy/middleware/Cql2ApplyFilterBodyMiddleware.py</code> <pre><code>@required_conformance(\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/basic-cql2\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-text\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-json\",\n)\n@dataclass(frozen=True)\nclass Cql2ApplyFilterBodyMiddleware:\n    \"\"\"Middleware to augment the request body with a CQL2 filter for POST/PUT/PATCH requests.\"\"\"\n\n    app: ASGIApp\n    state_key: str = \"cql2_filter\"\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Apply the CQL2 filter to the request body.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n        cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n        if not cql2_filter:\n            return await self.app(scope, receive, send)\n\n        if request.method not in [\"POST\", \"PUT\", \"PATCH\"]:\n            return await self.app(scope, receive, send)\n\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await receive()\n            if message[\"type\"] == \"http.request\":\n                body += message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n\n        try:\n            body_json = json.loads(body) if body else {}\n        except json.JSONDecodeError:\n            logger.warning(\"Failed to parse request body as JSON\")\n            from starlette.responses import JSONResponse\n\n            response = JSONResponse(\n                {\n                    \"code\": \"ParseError\",\n                    \"description\": \"Request body must be valid JSON.\",\n                },\n                status_code=400,\n            )\n            await response(scope, receive, send)\n            return\n\n        if not isinstance(body_json, dict):\n            logger.warning(\"Request body must be a JSON object\")\n            from starlette.responses import JSONResponse\n\n            response = JSONResponse(\n                {\n                    \"code\": \"TypeError\",\n                    \"description\": \"Request body must be a JSON object.\",\n                },\n                status_code=400,\n            )\n            await response(scope, receive, send)\n            return\n\n        new_body = json.dumps(\n            filters.append_body_filter(body_json, cql2_filter)\n        ).encode(\"utf-8\")\n\n        # Patch content-length in the headers\n        headers = dict(scope[\"headers\"])\n        headers[b\"content-length\"] = str(len(new_body)).encode(\"latin1\")\n        scope = dict(scope)\n        scope[\"headers\"] = list(headers.items())\n\n        async def new_receive():\n            return {\n                \"type\": \"http.request\",\n                \"body\": new_body,\n                \"more_body\": False,\n            }\n\n        await self.app(scope, new_receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterBodyMiddleware/#stac_auth_proxy.middleware.Cql2ApplyFilterBodyMiddleware.Cql2ApplyFilterBodyMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Apply the CQL2 filter to the request body.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2ApplyFilterBodyMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Apply the CQL2 filter to the request body.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n    cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n    if not cql2_filter:\n        return await self.app(scope, receive, send)\n\n    if request.method not in [\"POST\", \"PUT\", \"PATCH\"]:\n        return await self.app(scope, receive, send)\n\n    body = b\"\"\n    more_body = True\n    while more_body:\n        message = await receive()\n        if message[\"type\"] == \"http.request\":\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n\n    try:\n        body_json = json.loads(body) if body else {}\n    except json.JSONDecodeError:\n        logger.warning(\"Failed to parse request body as JSON\")\n        from starlette.responses import JSONResponse\n\n        response = JSONResponse(\n            {\n                \"code\": \"ParseError\",\n                \"description\": \"Request body must be valid JSON.\",\n            },\n            status_code=400,\n        )\n        await response(scope, receive, send)\n        return\n\n    if not isinstance(body_json, dict):\n        logger.warning(\"Request body must be a JSON object\")\n        from starlette.responses import JSONResponse\n\n        response = JSONResponse(\n            {\n                \"code\": \"TypeError\",\n                \"description\": \"Request body must be a JSON object.\",\n            },\n            status_code=400,\n        )\n        await response(scope, receive, send)\n        return\n\n    new_body = json.dumps(\n        filters.append_body_filter(body_json, cql2_filter)\n    ).encode(\"utf-8\")\n\n    # Patch content-length in the headers\n    headers = dict(scope[\"headers\"])\n    headers[b\"content-length\"] = str(len(new_body)).encode(\"latin1\")\n    scope = dict(scope)\n    scope[\"headers\"] = list(headers.items())\n\n    async def new_receive():\n        return {\n            \"type\": \"http.request\",\n            \"body\": new_body,\n            \"more_body\": False,\n        }\n\n    await self.app(scope, new_receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterQueryStringMiddleware/","title":"stac_auth_proxy.middleware.Cql2ApplyFilterQueryStringMiddleware","text":"<p>Middleware to inject CQL2 filters into the query string for GET/list endpoints.</p>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterQueryStringMiddleware/#stac_auth_proxy.middleware.Cql2ApplyFilterQueryStringMiddleware.Cql2ApplyFilterQueryStringMiddleware","title":"<code>Cql2ApplyFilterQueryStringMiddleware</code>  <code>dataclass</code>","text":"<p>Middleware to inject CQL2 filters into the query string for GET/list endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>state_key</code> <code>str</code> <code>'cql2_filter'</code> Source code in <code>src/stac_auth_proxy/middleware/Cql2ApplyFilterQueryStringMiddleware.py</code> <pre><code>@required_conformance(\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/basic-cql2\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-text\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-json\",\n)\n@dataclass(frozen=True)\nclass Cql2ApplyFilterQueryStringMiddleware:\n    \"\"\"Middleware to inject CQL2 filters into the query string for GET/list endpoints.\"\"\"\n\n    app: ASGIApp\n    state_key: str = \"cql2_filter\"\n\n    single_record_endpoints = [\n        r\"^/collections/([^/]+)/items/([^/]+)$\",\n        r\"^/collections/([^/]+)$\",\n    ]\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Apply the CQL2 filter to the query string.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n        cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n        if not cql2_filter:\n            return await self.app(scope, receive, send)\n\n        # Only handle GET requests that are not single-record endpoints\n        if request.method != \"GET\":\n            return await self.app(scope, receive, send)\n        if any(\n            re.match(expr, request.url.path) for expr in self.single_record_endpoints\n        ):\n            return await self.app(scope, receive, send)\n\n        # Inject filter into query string\n        scope = dict(scope)\n        scope[\"query_string\"] = filters.append_qs_filter(request.url.query, cql2_filter)\n        return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ApplyFilterQueryStringMiddleware/#stac_auth_proxy.middleware.Cql2ApplyFilterQueryStringMiddleware.Cql2ApplyFilterQueryStringMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Apply the CQL2 filter to the query string.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2ApplyFilterQueryStringMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Apply the CQL2 filter to the query string.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n    cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n    if not cql2_filter:\n        return await self.app(scope, receive, send)\n\n    # Only handle GET requests that are not single-record endpoints\n    if request.method != \"GET\":\n        return await self.app(scope, receive, send)\n    if any(\n        re.match(expr, request.url.path) for expr in self.single_record_endpoints\n    ):\n        return await self.app(scope, receive, send)\n\n    # Inject filter into query string\n    scope = dict(scope)\n    scope[\"query_string\"] = filters.append_qs_filter(request.url.query, cql2_filter)\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware/","title":"stac_auth_proxy.middleware.Cql2BuildFilterMiddleware","text":"<p>Middleware to build the Cql2Filter.</p>"},{"location":"reference/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware/#stac_auth_proxy.middleware.Cql2BuildFilterMiddleware.Cql2BuildFilterMiddleware","title":"<code>Cql2BuildFilterMiddleware</code>  <code>dataclass</code>","text":"<p>Middleware to build the Cql2Filter.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>state_key</code> <code>str</code> <code>'cql2_filter'</code> <code>collections_filter</code> <code>Callable | None</code> <code>None</code> <code>collections_filter_path</code> <code>str</code> <code>'^/collections(/[^/]+)?$'</code> <code>items_filter</code> <code>Callable | None</code> <code>None</code> <code>items_filter_path</code> <code>str</code> <code>'^(/collections/([^/]+)/items(/[^/]+)?$|/search$)'</code> Source code in <code>src/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware.py</code> <pre><code>@required_conformance(\n    \"http://www.opengis.net/spec/cql2/1.0/conf/basic-cql2\",\n    \"http://www.opengis.net/spec/cql2/1.0/conf/cql2-text\",\n    \"http://www.opengis.net/spec/cql2/1.0/conf/cql2-json\",\n)\n@dataclass(frozen=True)\nclass Cql2BuildFilterMiddleware:\n    \"\"\"Middleware to build the Cql2Filter.\"\"\"\n\n    app: ASGIApp\n\n    state_key: str = \"cql2_filter\"\n\n    # Filters\n    collections_filter: Optional[Callable] = None\n    collections_filter_path: str = r\"^/collections(/[^/]+)?$\"\n    items_filter: Optional[Callable] = None\n    items_filter_path: str = r\"^(/collections/([^/]+)/items(/[^/]+)?$|/search$)\"\n\n    def __post_init__(self):\n        \"\"\"Set required conformances based on the filter functions.\"\"\"\n        required_conformances = set()\n        if self.collections_filter:\n            logger.debug(\"Appending required conformance for collections filter\")\n            # https://github.com/stac-api-extensions/collection-search/blob/4825b4b1cee96bdc0cbfbb342d5060d0031976f0/README.md#L5\n            required_conformances.update(\n                [\n                    \"https://api.stacspec.org/v1.0.0/core\",\n                    r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/collection-search\",\n                    r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/collection-search#filter\",\n                    \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/simple-query\",\n                ]\n            )\n        if self.items_filter:\n            logger.debug(\"Appending required conformance for items filter\")\n            # https://github.com/stac-api-extensions/filter/blob/c763dbbf0a52210ab8d9866ff048da448d270f93/README.md#conformance-classes\n            required_conformances.update(\n                [\n                    \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/filter\",\n                    \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/features-filter\",\n                    r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/item-search#filter\",\n                ]\n            )\n\n        # Must set required conformances on class\n        self.__class__.__required_conformances__ = required_conformances.union(\n            getattr(self.__class__, \"__required_conformances__\", [])\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Build the CQL2 filter, place on the request state.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n\n        if request.method.upper() == \"OPTIONS\":\n            logger.debug(\"Skipping CQL2 filter build for OPTIONS request\")\n            return await self.app(scope, receive, send)\n\n        filter_builder = self._get_filter(request.url.path)\n        if not filter_builder:\n            return await self.app(scope, receive, send)\n\n        filter_expr = await filter_builder(\n            {\n                \"req\": {\n                    \"path\": request.url.path,\n                    \"method\": request.method,\n                    \"query_params\": dict(request.query_params),\n                    \"path_params\": requests.extract_variables(request.url.path),\n                    \"headers\": dict(request.headers),\n                },\n                **scope[\"state\"],\n            }\n        )\n        cql2_filter = Expr(filter_expr)\n        try:\n            cql2_filter.validate()\n        except ValidationError:\n            logger.error(\"Invalid CQL2 filter: %s\", filter_expr)\n            return Response(status_code=502, content=\"Invalid CQL2 filter\")\n        setattr(request.state, self.state_key, cql2_filter)\n\n        return await self.app(scope, receive, send)\n\n    def _get_filter(\n        self, path: str\n    ) -&gt; Optional[Callable[..., Awaitable[str | dict[str, Any]]]]:\n        \"\"\"Get the CQL2 filter builder for the given path.\"\"\"\n        endpoint_filters = [\n            (self.collections_filter_path, self.collections_filter),\n            (self.items_filter_path, self.items_filter),\n        ]\n        for expr, builder in endpoint_filters:\n            if re.match(expr, path):\n                return builder\n        return None\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware/#stac_auth_proxy.middleware.Cql2BuildFilterMiddleware.Cql2BuildFilterMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Build the CQL2 filter, place on the request state.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Build the CQL2 filter, place on the request state.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n\n    if request.method.upper() == \"OPTIONS\":\n        logger.debug(\"Skipping CQL2 filter build for OPTIONS request\")\n        return await self.app(scope, receive, send)\n\n    filter_builder = self._get_filter(request.url.path)\n    if not filter_builder:\n        return await self.app(scope, receive, send)\n\n    filter_expr = await filter_builder(\n        {\n            \"req\": {\n                \"path\": request.url.path,\n                \"method\": request.method,\n                \"query_params\": dict(request.query_params),\n                \"path_params\": requests.extract_variables(request.url.path),\n                \"headers\": dict(request.headers),\n            },\n            **scope[\"state\"],\n        }\n    )\n    cql2_filter = Expr(filter_expr)\n    try:\n        cql2_filter.validate()\n    except ValidationError:\n        logger.error(\"Invalid CQL2 filter: %s\", filter_expr)\n        return Response(status_code=502, content=\"Invalid CQL2 filter\")\n    setattr(request.state, self.state_key, cql2_filter)\n\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware/#stac_auth_proxy.middleware.Cql2BuildFilterMiddleware.Cql2BuildFilterMiddleware.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Set required conformances based on the filter functions.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2BuildFilterMiddleware.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Set required conformances based on the filter functions.\"\"\"\n    required_conformances = set()\n    if self.collections_filter:\n        logger.debug(\"Appending required conformance for collections filter\")\n        # https://github.com/stac-api-extensions/collection-search/blob/4825b4b1cee96bdc0cbfbb342d5060d0031976f0/README.md#L5\n        required_conformances.update(\n            [\n                \"https://api.stacspec.org/v1.0.0/core\",\n                r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/collection-search\",\n                r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/collection-search#filter\",\n                \"http://www.opengis.net/spec/ogcapi-common-2/1.0/conf/simple-query\",\n            ]\n        )\n    if self.items_filter:\n        logger.debug(\"Appending required conformance for items filter\")\n        # https://github.com/stac-api-extensions/filter/blob/c763dbbf0a52210ab8d9866ff048da448d270f93/README.md#conformance-classes\n        required_conformances.update(\n            [\n                \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/filter\",\n                \"http://www.opengis.net/spec/ogcapi-features-3/1.0/conf/features-filter\",\n                r\"https://api.stacspec.org/v1\\.0\\.0(?:-[\\w\\.]+)?/item-search#filter\",\n            ]\n        )\n\n    # Must set required conformances on class\n    self.__class__.__required_conformances__ = required_conformances.union(\n        getattr(self.__class__, \"__required_conformances__\", [])\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2RewriteLinksFilterMiddleware/","title":"stac_auth_proxy.middleware.Cql2RewriteLinksFilterMiddleware","text":"<p>Middleware to rewrite 'filter' in .links of the JSON response, removing the filter from the request state.</p>"},{"location":"reference/stac_auth_proxy/middleware/Cql2RewriteLinksFilterMiddleware/#stac_auth_proxy.middleware.Cql2RewriteLinksFilterMiddleware.Cql2RewriteLinksFilterMiddleware","title":"<code>Cql2RewriteLinksFilterMiddleware</code>  <code>dataclass</code>","text":"<p>ASGI middleware to rewrite 'filter' in .links of the JSON response, removing the filter from the request state.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>state_key</code> <code>str</code> <code>'cql2_filter'</code> Source code in <code>src/stac_auth_proxy/middleware/Cql2RewriteLinksFilterMiddleware.py</code> <pre><code>@dataclass(frozen=True)\nclass Cql2RewriteLinksFilterMiddleware:\n    \"\"\"ASGI middleware to rewrite 'filter' in .links of the JSON response, removing the filter from the request state.\"\"\"\n\n    app: ASGIApp\n    state_key: str = \"cql2_filter\"\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Replace 'filter' in .links of the JSON response to state before we had applied the filter.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n        original_filter = request.query_params.get(\"filter\")\n        cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n        if cql2_filter is None:\n            # No filter set, just pass through\n            return await self.app(scope, receive, send)\n\n        # Intercept the response\n        response_start = None\n        body_chunks = []\n        more_body = True\n\n        async def send_wrapper(message: Message):\n            nonlocal response_start, body_chunks, more_body\n            if message[\"type\"] == \"http.response.start\":\n                response_start = message\n            elif message[\"type\"] == \"http.response.body\":\n                body_chunks.append(message.get(\"body\", b\"\"))\n                more_body = message.get(\"more_body\", False)\n                if not more_body:\n                    await self._process_and_send_response(\n                        response_start, body_chunks, send, original_filter\n                    )\n            else:\n                await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n\n    async def _process_and_send_response(\n        self,\n        response_start: Message,\n        body_chunks: list[bytes],\n        send: Send,\n        original_filter: Optional[str],\n    ):\n        body = b\"\".join(body_chunks)\n        try:\n            data = json.loads(body)\n        except Exception:\n            await send(response_start)\n            await send({\"type\": \"http.response.body\", \"body\": body, \"more_body\": False})\n            return\n\n        cql2_filter = Expr(original_filter) if original_filter else None\n        links = data.get(\"links\")\n        if isinstance(links, list):\n            for link in links:\n                # Handle filter in query string\n                if \"href\" in link:\n                    url = urlparse(link[\"href\"])\n                    qs = parse_qs(url.query)\n                    if \"filter\" in qs:\n                        if cql2_filter:\n                            qs[\"filter\"] = [cql2_filter.to_text()]\n                        else:\n                            qs.pop(\"filter\", None)\n                            qs.pop(\"filter-lang\", None)\n                        new_query = urlencode(qs, doseq=True)\n                        link[\"href\"] = urlunparse(url._replace(query=new_query))\n\n                # Handle filter in body (for POST links)\n                if \"body\" in link and isinstance(link[\"body\"], dict):\n                    if \"filter\" in link[\"body\"]:\n                        if cql2_filter:\n                            link[\"body\"][\"filter\"] = cql2_filter.to_json()\n                        else:\n                            link[\"body\"].pop(\"filter\", None)\n                            link[\"body\"].pop(\"filter-lang\", None)\n\n        # Send the modified response\n        new_body = json.dumps(data).encode(\"utf-8\")\n\n        # Patch content-length\n        headers = [\n            (k, v) for k, v in response_start[\"headers\"] if k != b\"content-length\"\n        ]\n        headers.append((b\"content-length\", str(len(new_body)).encode(\"latin1\")))\n        response_start = dict(response_start)\n        response_start[\"headers\"] = headers\n        await send(response_start)\n        await send({\"type\": \"http.response.body\", \"body\": new_body, \"more_body\": False})\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2RewriteLinksFilterMiddleware/#stac_auth_proxy.middleware.Cql2RewriteLinksFilterMiddleware.Cql2RewriteLinksFilterMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Replace 'filter' in .links of the JSON response to state before we had applied the filter.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2RewriteLinksFilterMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Replace 'filter' in .links of the JSON response to state before we had applied the filter.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n    original_filter = request.query_params.get(\"filter\")\n    cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n    if cql2_filter is None:\n        # No filter set, just pass through\n        return await self.app(scope, receive, send)\n\n    # Intercept the response\n    response_start = None\n    body_chunks = []\n    more_body = True\n\n    async def send_wrapper(message: Message):\n        nonlocal response_start, body_chunks, more_body\n        if message[\"type\"] == \"http.response.start\":\n            response_start = message\n        elif message[\"type\"] == \"http.response.body\":\n            body_chunks.append(message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n            if not more_body:\n                await self._process_and_send_response(\n                    response_start, body_chunks, send, original_filter\n                )\n        else:\n            await send(message)\n\n    await self.app(scope, receive, send_wrapper)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ValidateResponseBodyMiddleware/","title":"stac_auth_proxy.middleware.Cql2ValidateResponseBodyMiddleware","text":"<p>Middleware to validate the response body with a CQL2 filter for single-record endpoints.</p>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ValidateResponseBodyMiddleware/#stac_auth_proxy.middleware.Cql2ValidateResponseBodyMiddleware.Cql2ValidateResponseBodyMiddleware","title":"<code>Cql2ValidateResponseBodyMiddleware</code>  <code>dataclass</code>","text":"<p>ASGI middleware to validate the response body with a CQL2 filter for single-record endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>state_key</code> <code>str</code> <code>'cql2_filter'</code> Source code in <code>src/stac_auth_proxy/middleware/Cql2ValidateResponseBodyMiddleware.py</code> <pre><code>@required_conformance(\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/basic-cql2\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-text\",\n    r\"http://www.opengis.net/spec/cql2/1.0/conf/cql2-json\",\n)\n@dataclass\nclass Cql2ValidateResponseBodyMiddleware:\n    \"\"\"ASGI middleware to validate the response body with a CQL2 filter for single-record endpoints.\"\"\"\n\n    app: ASGIApp\n    state_key: str = \"cql2_filter\"\n\n    single_record_endpoints = [\n        r\"^/collections/([^/]+)/items/([^/]+)$\",\n        r\"^/collections/([^/]+)$\",\n    ]\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Validate the response body with a CQL2 filter for single-record endpoints.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n        cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n        if not cql2_filter:\n            return await self.app(scope, receive, send)\n\n        if not any(\n            re.match(expr, request.url.path) for expr in self.single_record_endpoints\n        ):\n            return await self.app(scope, receive, send)\n\n        # Intercept the response\n        response_start = None\n        body_chunks = []\n        more_body = True\n\n        async def send_wrapper(message: Message):\n            nonlocal response_start, body_chunks, more_body\n            if message[\"type\"] == \"http.response.start\":\n                response_start = message\n            elif message[\"type\"] == \"http.response.body\":\n                body_chunks.append(message.get(\"body\", b\"\"))\n                more_body = message.get(\"more_body\", False)\n                if not more_body:\n                    await self._process_and_send_response(\n                        response_start, body_chunks, send, cql2_filter\n                    )\n            else:\n                await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n\n    async def _process_and_send_response(\n        self, response_start, body_chunks, send, cql2_filter\n    ):\n        body = b\"\".join(body_chunks)\n        try:\n            body_json = json.loads(body)\n        except json.JSONDecodeError:\n            logger.warning(\"Failed to parse response body as JSON\")\n            await self._send_json_response(\n                send,\n                status=502,\n                content={\n                    \"code\": \"ParseError\",\n                    \"description\": \"Failed to parse response body as JSON\",\n                },\n            )\n            return\n\n        try:\n            cql2_matches = cql2_filter.matches(body_json)\n        except Exception as e:\n            cql2_matches = False\n            logger.warning(\"Failed to apply filter: %s\", e)\n\n        if cql2_matches:\n            logger.debug(\"Response matches filter, returning record\")\n            # Send the original response start\n            await send(response_start)\n            # Send the filtered body\n            await send(\n                {\n                    \"type\": \"http.response.body\",\n                    \"body\": json.dumps(body_json).encode(\"utf-8\"),\n                    \"more_body\": False,\n                }\n            )\n        else:\n            logger.debug(\"Response did not match filter, returning 404\")\n            await self._send_json_response(\n                send,\n                status=404,\n                content={\"code\": \"NotFoundError\", \"description\": \"Record not found.\"},\n            )\n\n    async def _send_json_response(self, send, status, content):\n        response_bytes = json.dumps(content).encode(\"utf-8\")\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": status,\n                \"headers\": [\n                    (b\"content-type\", b\"application/json\"),\n                    (b\"content-length\", str(len(response_bytes)).encode(\"latin1\")),\n                ],\n            }\n        )\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": response_bytes,\n                \"more_body\": False,\n            }\n        )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/Cql2ValidateResponseBodyMiddleware/#stac_auth_proxy.middleware.Cql2ValidateResponseBodyMiddleware.Cql2ValidateResponseBodyMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Validate the response body with a CQL2 filter for single-record endpoints.</p> Source code in <code>src/stac_auth_proxy/middleware/Cql2ValidateResponseBodyMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Validate the response body with a CQL2 filter for single-record endpoints.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n    cql2_filter: Optional[Expr] = getattr(request.state, self.state_key, None)\n    if not cql2_filter:\n        return await self.app(scope, receive, send)\n\n    if not any(\n        re.match(expr, request.url.path) for expr in self.single_record_endpoints\n    ):\n        return await self.app(scope, receive, send)\n\n    # Intercept the response\n    response_start = None\n    body_chunks = []\n    more_body = True\n\n    async def send_wrapper(message: Message):\n        nonlocal response_start, body_chunks, more_body\n        if message[\"type\"] == \"http.response.start\":\n            response_start = message\n        elif message[\"type\"] == \"http.response.body\":\n            body_chunks.append(message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n            if not more_body:\n                await self._process_and_send_response(\n                    response_start, body_chunks, send, cql2_filter\n                )\n        else:\n            await send(message)\n\n    await self.app(scope, receive, send_wrapper)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/","title":"stac_auth_proxy.middleware.EnforceAuthMiddleware","text":"<p>Middleware to enforce authentication.</p>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.EnforceAuthMiddleware","title":"<code>EnforceAuthMiddleware</code>  <code>dataclass</code>","text":"<p>Middleware to enforce authentication.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>private_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>public_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>default_public</code> <code>bool</code> required <code>oidc_discovery_url</code> <code>HttpUrl</code> required <code>allowed_jwt_audiences</code> <code>Sequence[str] | None</code> <code>None</code> <code>state_key</code> <code>str</code> <code>'payload'</code> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>@dataclass\nclass EnforceAuthMiddleware:\n    \"\"\"Middleware to enforce authentication.\"\"\"\n\n    app: ASGIApp\n    private_endpoints: EndpointMethods\n    public_endpoints: EndpointMethods\n    default_public: bool\n    oidc_discovery_url: HttpUrl\n    allowed_jwt_audiences: Optional[Sequence[str]] = None\n    state_key: str = \"payload\"\n\n    _oidc_config: Optional[OidcService] = None\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Enforce authentication.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        request = Request(scope)\n\n        # Skip authentication for OPTIONS requests, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n        if request.method == \"OPTIONS\":\n            return await self.app(scope, receive, send)\n\n        match = find_match(\n            request.url.path,\n            request.method,\n            private_endpoints=self.private_endpoints,\n            public_endpoints=self.public_endpoints,\n            default_public=self.default_public,\n        )\n        try:\n            payload = self.validate_token(\n                request.headers.get(\"Authorization\"),\n                auto_error=match.is_private,\n                required_scopes=match.required_scopes,\n            )\n\n        except HTTPException as e:\n            response = JSONResponse({\"detail\": e.detail}, status_code=e.status_code)\n            return await response(scope, receive, send)\n\n        # Set the payload in the request state\n        setattr(\n            request.state,\n            self.state_key,\n            payload,\n        )\n        setattr(request.state, \"oidc_metadata\", self.oidc_config.metadata)\n        return await self.app(scope, receive, send)\n\n    def validate_token(\n        self,\n        auth_header: Annotated[str, Security(...)],\n        auto_error: bool = True,\n        required_scopes: Optional[Sequence[str]] = None,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"Dependency to validate an OIDC token.\"\"\"\n        if not auth_header:\n            if auto_error:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            return None\n\n        # Extract token from header\n        token_parts = auth_header.split(\" \")\n        if len(token_parts) != 2 or token_parts[0].lower() != \"bearer\":\n            logger.error(\"Invalid Authorization header format\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid Authorization header format\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        [_, token] = token_parts\n\n        # Parse &amp; validate token\n        try:\n            key = self.oidc_config.jwks_client.get_signing_key_from_jwt(token).key\n            payload = jwt.decode(\n                token,\n                key,\n                algorithms=[\"RS256\"],\n                # NOTE: Audience validation MUST match audience claim if set in token (https://pyjwt.readthedocs.io/en/stable/changelog.html?highlight=audience#id40)\n                audience=self.allowed_jwt_audiences,\n            )\n        except jwt.InvalidAudienceError as e:\n            logger.error(\"Token audience validation failed: %s\", str(e))\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token audience\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        except (\n            jwt.exceptions.InvalidTokenError,\n            jwt.exceptions.DecodeError,\n            jwt.exceptions.PyJWKClientError,\n        ) as e:\n            logger.error(\"Token validation failed: %s\", type(e).__name__)\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid or expired token\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            ) from e\n\n        # Check authorization (scopes)\n        if required_scopes:\n            token_scopes = set(payload.get(\"scope\", \"\").split())\n            missing_scopes = set(required_scopes) - token_scopes\n            if missing_scopes:\n                logger.warning(\n                    \"Insufficient scopes for user %s. Required: %s, Has: %s\",\n                    payload.get(\"sub\"),\n                    required_scopes,\n                    token_scopes,\n                )\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=f\"Insufficient permissions. Required scopes: {', '.join(missing_scopes)}\",\n                    headers={\n                        \"WWW-Authenticate\": f'Bearer scope=\"{\" \".join(required_scopes)}\"'\n                    },\n                )\n\n        return payload\n\n    @property\n    def oidc_config(self) -&gt; OidcService:\n        \"\"\"Get the OIDC configuration.\"\"\"\n        if not self._oidc_config:\n            self._oidc_config = OidcService(oidc_discovery_url=self.oidc_discovery_url)\n        return self._oidc_config\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.EnforceAuthMiddleware.oidc_config","title":"<code>oidc_config: OidcService</code>  <code>property</code>","text":"<p>Get the OIDC configuration.</p>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.EnforceAuthMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Enforce authentication.</p> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Enforce authentication.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    request = Request(scope)\n\n    # Skip authentication for OPTIONS requests, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n    if request.method == \"OPTIONS\":\n        return await self.app(scope, receive, send)\n\n    match = find_match(\n        request.url.path,\n        request.method,\n        private_endpoints=self.private_endpoints,\n        public_endpoints=self.public_endpoints,\n        default_public=self.default_public,\n    )\n    try:\n        payload = self.validate_token(\n            request.headers.get(\"Authorization\"),\n            auto_error=match.is_private,\n            required_scopes=match.required_scopes,\n        )\n\n    except HTTPException as e:\n        response = JSONResponse({\"detail\": e.detail}, status_code=e.status_code)\n        return await response(scope, receive, send)\n\n    # Set the payload in the request state\n    setattr(\n        request.state,\n        self.state_key,\n        payload,\n    )\n    setattr(request.state, \"oidc_metadata\", self.oidc_config.metadata)\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.EnforceAuthMiddleware.validate_token","title":"<code>validate_token(auth_header: Annotated[str, Security(...)], auto_error: bool = True, required_scopes: Optional[Sequence[str]] = None) -&gt; Optional[dict[str, Any]]</code>","text":"<p>Dependency to validate an OIDC token.</p> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>def validate_token(\n    self,\n    auth_header: Annotated[str, Security(...)],\n    auto_error: bool = True,\n    required_scopes: Optional[Sequence[str]] = None,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"Dependency to validate an OIDC token.\"\"\"\n    if not auth_header:\n        if auto_error:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not authenticated\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        return None\n\n    # Extract token from header\n    token_parts = auth_header.split(\" \")\n    if len(token_parts) != 2 or token_parts[0].lower() != \"bearer\":\n        logger.error(\"Invalid Authorization header format\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid Authorization header format\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    [_, token] = token_parts\n\n    # Parse &amp; validate token\n    try:\n        key = self.oidc_config.jwks_client.get_signing_key_from_jwt(token).key\n        payload = jwt.decode(\n            token,\n            key,\n            algorithms=[\"RS256\"],\n            # NOTE: Audience validation MUST match audience claim if set in token (https://pyjwt.readthedocs.io/en/stable/changelog.html?highlight=audience#id40)\n            audience=self.allowed_jwt_audiences,\n        )\n    except jwt.InvalidAudienceError as e:\n        logger.error(\"Token audience validation failed: %s\", str(e))\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid token audience\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    except (\n        jwt.exceptions.InvalidTokenError,\n        jwt.exceptions.DecodeError,\n        jwt.exceptions.PyJWKClientError,\n    ) as e:\n        logger.error(\"Token validation failed: %s\", type(e).__name__)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired token\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        ) from e\n\n    # Check authorization (scopes)\n    if required_scopes:\n        token_scopes = set(payload.get(\"scope\", \"\").split())\n        missing_scopes = set(required_scopes) - token_scopes\n        if missing_scopes:\n            logger.warning(\n                \"Insufficient scopes for user %s. Required: %s, Has: %s\",\n                payload.get(\"sub\"),\n                required_scopes,\n                token_scopes,\n            )\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions. Required scopes: {', '.join(missing_scopes)}\",\n                headers={\n                    \"WWW-Authenticate\": f'Bearer scope=\"{\" \".join(required_scopes)}\"'\n                },\n            )\n\n    return payload\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.OidcFetchError","title":"<code>OidcFetchError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Error fetching OIDC configuration.</p> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>class OidcFetchError(Exception):\n    \"\"\"Error fetching OIDC configuration.\"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.OidcService","title":"<code>OidcService</code>  <code>dataclass</code>","text":"<p>OIDC configuration and JWKS client.</p> <p>Parameters:</p> Name Type Description Default <code>oidc_discovery_url</code> <code>HttpUrl</code> required <p>Attributes:</p> Name Type Description <code>jwks_client</code> <code>PyJWKClient</code> <code>metadata</code> <code>dict[str, Any]</code> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>@dataclass\nclass OidcService:\n    \"\"\"OIDC configuration and JWKS client.\"\"\"\n\n    oidc_discovery_url: HttpUrl\n    jwks_client: jwt.PyJWKClient = field(init=False)\n    metadata: dict[str, Any] = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize OIDC config and JWKS client.\"\"\"\n        logger.debug(\"Requesting OIDC config\")\n        origin_url = str(self.oidc_discovery_url)\n\n        try:\n            response = httpx.get(origin_url)\n            response.raise_for_status()\n            self.metadata = response.json()\n            assert self.metadata, \"OIDC metadata is empty\"\n\n            # NOTE: We manually replace the origin of the jwks_uri in the event that\n            # the jwks_uri is not available from within the proxy.\n            oidc_url = urlparse(origin_url)\n            jwks_uri = urlunparse(\n                urlparse(self.metadata[\"jwks_uri\"])._replace(\n                    netloc=oidc_url.netloc, scheme=oidc_url.scheme\n                )\n            )\n            if jwks_uri != self.metadata[\"jwks_uri\"]:\n                logger.warning(\n                    \"OIDC Discovery reported a JWKS URI of %s but we're going to use %s to match the OIDC Discovery URL\",\n                    self.metadata[\"jwks_uri\"],\n                    jwks_uri,\n                )\n            self.jwks_client = jwt.PyJWKClient(jwks_uri)\n        except httpx.HTTPStatusError as e:\n            logger.error(\n                \"Received a non-200 response when fetching OIDC config: %s\",\n                e.response.text,\n            )\n            raise OidcFetchError(\n                f\"Request for OIDC config failed with status {e.response.status_code}\"\n            ) from e\n        except httpx.RequestError as e:\n            logger.error(\"Error fetching OIDC config from %s: %s\", origin_url, str(e))\n            raise OidcFetchError(f\"Request for OIDC config failed: {str(e)}\") from e\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/EnforceAuthMiddleware/#stac_auth_proxy.middleware.EnforceAuthMiddleware.OidcService.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Initialize OIDC config and JWKS client.</p> Source code in <code>src/stac_auth_proxy/middleware/EnforceAuthMiddleware.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initialize OIDC config and JWKS client.\"\"\"\n    logger.debug(\"Requesting OIDC config\")\n    origin_url = str(self.oidc_discovery_url)\n\n    try:\n        response = httpx.get(origin_url)\n        response.raise_for_status()\n        self.metadata = response.json()\n        assert self.metadata, \"OIDC metadata is empty\"\n\n        # NOTE: We manually replace the origin of the jwks_uri in the event that\n        # the jwks_uri is not available from within the proxy.\n        oidc_url = urlparse(origin_url)\n        jwks_uri = urlunparse(\n            urlparse(self.metadata[\"jwks_uri\"])._replace(\n                netloc=oidc_url.netloc, scheme=oidc_url.scheme\n            )\n        )\n        if jwks_uri != self.metadata[\"jwks_uri\"]:\n            logger.warning(\n                \"OIDC Discovery reported a JWKS URI of %s but we're going to use %s to match the OIDC Discovery URL\",\n                self.metadata[\"jwks_uri\"],\n                jwks_uri,\n            )\n        self.jwks_client = jwt.PyJWKClient(jwks_uri)\n    except httpx.HTTPStatusError as e:\n        logger.error(\n            \"Received a non-200 response when fetching OIDC config: %s\",\n            e.response.text,\n        )\n        raise OidcFetchError(\n            f\"Request for OIDC config failed with status {e.response.status_code}\"\n        ) from e\n    except httpx.RequestError as e:\n        logger.error(\"Error fetching OIDC config from %s: %s\", origin_url, str(e))\n        raise OidcFetchError(f\"Request for OIDC config failed: {str(e)}\") from e\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/ProcessLinksMiddleware/","title":"stac_auth_proxy.middleware.ProcessLinksMiddleware","text":"<p>Middleware to remove the application root path from incoming requests and update links in responses.</p>"},{"location":"reference/stac_auth_proxy/middleware/ProcessLinksMiddleware/#stac_auth_proxy.middleware.ProcessLinksMiddleware.ProcessLinksMiddleware","title":"<code>ProcessLinksMiddleware</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonResponseMiddleware</code></p> <p>Middleware to update links in responses, removing the upstream_url path and adding the root_path if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>upstream_url</code> <code>str</code> required <code>root_path</code> <code>str | None</code> <code>None</code> <code>json_content_type_expr</code> <code>str</code> <code>'application/(geo\\\\+)?json'</code> Source code in <code>src/stac_auth_proxy/middleware/ProcessLinksMiddleware.py</code> <pre><code>@dataclass\nclass ProcessLinksMiddleware(JsonResponseMiddleware):\n    \"\"\"\n    Middleware to update links in responses, removing the upstream_url path and adding\n    the root_path if it exists.\n    \"\"\"\n\n    app: ASGIApp\n    upstream_url: str\n    root_path: Optional[str] = None\n\n    json_content_type_expr: str = r\"application/(geo\\+)?json\"\n\n    def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n        \"\"\"Only transform responses with JSON content type.\"\"\"\n        return bool(\n            re.match(\n                self.json_content_type_expr,\n                Headers(scope=scope).get(\"content-type\", \"\"),\n            )\n        )\n\n    def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n        \"\"\"Update links in the response to include root_path.\"\"\"\n        # Get the client's actual base URL (accounting for load balancers/proxies)\n        req_base_url = get_base_url(request)\n        parsed_req_url = urlparse(req_base_url)\n        parsed_upstream_url = urlparse(self.upstream_url)\n\n        for link in get_links(data):\n            try:\n                self._update_link(link, parsed_req_url, parsed_upstream_url)\n            except Exception as e:\n                logger.error(\n                    \"Failed to parse link href %r, (ignoring): %s\",\n                    link.get(\"href\"),\n                    str(e),\n                )\n        return data\n\n    def _update_link(\n        self, link: dict[str, Any], request_url: ParseResult, upstream_url: ParseResult\n    ) -&gt; None:\n        \"\"\"\n        Ensure that link hrefs that are local to upstream url are rewritten as local to\n        the proxy.\n        \"\"\"\n        if \"href\" not in link:\n            logger.warning(\"Link %r has no href\", link)\n            return\n\n        parsed_link = urlparse(link[\"href\"])\n\n        if parsed_link.netloc not in [\n            request_url.netloc,\n            upstream_url.netloc,\n        ]:\n            logger.debug(\n                \"Ignoring link %s because it is not for an endpoint behind this proxy (%s or %s)\",\n                link[\"href\"],\n                request_url.netloc,\n                upstream_url.netloc,\n            )\n            return\n\n        # If the link path is not a descendant of the upstream path, don't transform it\n        if upstream_url.path != \"/\" and not parsed_link.path.startswith(\n            upstream_url.path\n        ):\n            logger.debug(\n                \"Ignoring link %s because it is not descendant of upstream path (%s)\",\n                link[\"href\"],\n                upstream_url.path,\n            )\n            return\n\n        # Replace the upstream host with the client's host\n        if parsed_link.netloc == upstream_url.netloc:\n            parsed_link = parsed_link._replace(netloc=request_url.netloc)._replace(\n                scheme=request_url.scheme\n            )\n\n        # Remove the upstream prefix from the link path\n        if upstream_url.path != \"/\" and parsed_link.path.startswith(upstream_url.path):\n            parsed_link = parsed_link._replace(\n                path=parsed_link.path[len(upstream_url.path) :]\n            )\n\n        # Add the root_path to the link if it exists\n        if self.root_path:\n            parsed_link = parsed_link._replace(\n                path=f\"{self.root_path}{parsed_link.path}\"\n            )\n\n        updated_href = urlunparse(parsed_link)\n        if updated_href == link[\"href\"]:\n            return\n\n        logger.debug(\n            \"Rewriting %r link %r to %r\",\n            link.get(\"rel\"),\n            link[\"href\"],\n            updated_href,\n        )\n\n        link[\"href\"] = updated_href\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/ProcessLinksMiddleware/#stac_auth_proxy.middleware.ProcessLinksMiddleware.ProcessLinksMiddleware.should_transform_response","title":"<code>should_transform_response(request: Request, scope: Scope) -&gt; bool</code>","text":"<p>Only transform responses with JSON content type.</p> Source code in <code>src/stac_auth_proxy/middleware/ProcessLinksMiddleware.py</code> <pre><code>def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n    \"\"\"Only transform responses with JSON content type.\"\"\"\n    return bool(\n        re.match(\n            self.json_content_type_expr,\n            Headers(scope=scope).get(\"content-type\", \"\"),\n        )\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/ProcessLinksMiddleware/#stac_auth_proxy.middleware.ProcessLinksMiddleware.ProcessLinksMiddleware.transform_json","title":"<code>transform_json(data: dict[str, Any], request: Request) -&gt; dict[str, Any]</code>","text":"<p>Update links in the response to include root_path.</p> Source code in <code>src/stac_auth_proxy/middleware/ProcessLinksMiddleware.py</code> <pre><code>def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n    \"\"\"Update links in the response to include root_path.\"\"\"\n    # Get the client's actual base URL (accounting for load balancers/proxies)\n    req_base_url = get_base_url(request)\n    parsed_req_url = urlparse(req_base_url)\n    parsed_upstream_url = urlparse(self.upstream_url)\n\n    for link in get_links(data):\n        try:\n            self._update_link(link, parsed_req_url, parsed_upstream_url)\n        except Exception as e:\n            logger.error(\n                \"Failed to parse link href %r, (ignoring): %s\",\n                link.get(\"href\"),\n                str(e),\n            )\n    return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/RemoveRootPathMiddleware/","title":"stac_auth_proxy.middleware.RemoveRootPathMiddleware","text":"<p>Middleware to remove ROOT_PATH from incoming requests and update links in responses.</p>"},{"location":"reference/stac_auth_proxy/middleware/RemoveRootPathMiddleware/#stac_auth_proxy.middleware.RemoveRootPathMiddleware.RemoveRootPathMiddleware","title":"<code>RemoveRootPathMiddleware</code>  <code>dataclass</code>","text":"<p>Middleware to remove the root path of the request before it is sent to the upstream server.</p> <p>IMPORTANT: This middleware must be placed early in the middleware chain (ie late in the order of declaration) so that it trims the root_path from the request path before any middleware that may need to use the request path (e.g. EnforceAuthMiddleware).</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>root_path</code> <code>str</code> required Source code in <code>src/stac_auth_proxy/middleware/RemoveRootPathMiddleware.py</code> <pre><code>@dataclass\nclass RemoveRootPathMiddleware:\n    \"\"\"\n    Middleware to remove the root path of the request before it is sent to the upstream\n    server.\n\n    IMPORTANT: This middleware must be placed early in the middleware chain (ie late in\n    the order of declaration) so that it trims the root_path from the request path before\n    any middleware that may need to use the request path (e.g. EnforceAuthMiddleware).\n    \"\"\"\n\n    app: ASGIApp\n    root_path: str\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Remove ROOT_PATH from the request path if it exists.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        # If root_path is set and path doesn't start with it, return 404\n        if self.root_path and not scope[\"path\"].startswith(self.root_path):\n            response = Response(\"Not Found\", status_code=404)\n            logger.error(\n                f\"Root path {self.root_path!r} not found in path {scope['path']!r}\"\n            )\n            await response(scope, receive, send)\n            return\n\n        # Remove root_path if it exists at the start of the path\n        if scope[\"path\"].startswith(self.root_path):\n            scope[\"raw_path\"] = scope[\"path\"].encode()\n            scope[\"path\"] = scope[\"path\"][len(self.root_path) :] or \"/\"\n\n        return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/RemoveRootPathMiddleware/#stac_auth_proxy.middleware.RemoveRootPathMiddleware.RemoveRootPathMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Remove ROOT_PATH from the request path if it exists.</p> Source code in <code>src/stac_auth_proxy/middleware/RemoveRootPathMiddleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Remove ROOT_PATH from the request path if it exists.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    # If root_path is set and path doesn't start with it, return 404\n    if self.root_path and not scope[\"path\"].startswith(self.root_path):\n        response = Response(\"Not Found\", status_code=404)\n        logger.error(\n            f\"Root path {self.root_path!r} not found in path {scope['path']!r}\"\n        )\n        await response(scope, receive, send)\n        return\n\n    # Remove root_path if it exists at the start of the path\n    if scope[\"path\"].startswith(self.root_path):\n        scope[\"raw_path\"] = scope[\"path\"].encode()\n        scope[\"path\"] = scope[\"path\"][len(self.root_path) :] or \"/\"\n\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/UpdateOpenApiMiddleware/","title":"stac_auth_proxy.middleware.UpdateOpenApiMiddleware","text":"<p>Middleware to add auth information to the OpenAPI spec served by upstream API.</p>"},{"location":"reference/stac_auth_proxy/middleware/UpdateOpenApiMiddleware/#stac_auth_proxy.middleware.UpdateOpenApiMiddleware.OpenApiMiddleware","title":"<code>OpenApiMiddleware</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonResponseMiddleware</code></p> <p>Middleware to add the OpenAPI spec to the response.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>openapi_spec_path</code> <code>str</code> required <code>oidc_discovery_url</code> <code>str</code> required <code>private_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>public_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>default_public</code> <code>bool</code> required <code>root_path</code> <code>str</code> <code>''</code> <code>auth_scheme_name</code> <code>str</code> <code>'oidcAuth'</code> <code>auth_scheme_override</code> <code>dict | None</code> <code>None</code> <code>json_content_type_expr</code> <code>str</code> <code>'application/(vnd\\\\.oai\\\\.openapi\\\\+json?|json)'</code> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>@dataclass(frozen=True)\nclass OpenApiMiddleware(JsonResponseMiddleware):\n    \"\"\"Middleware to add the OpenAPI spec to the response.\"\"\"\n\n    app: ASGIApp\n    openapi_spec_path: str\n    oidc_discovery_url: str\n    private_endpoints: EndpointMethods\n    public_endpoints: EndpointMethods\n    default_public: bool\n    root_path: str = \"\"\n    auth_scheme_name: str = \"oidcAuth\"\n    auth_scheme_override: Optional[dict] = None\n\n    json_content_type_expr: str = r\"application/(vnd\\.oai\\.openapi\\+json?|json)\"\n\n    def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n        \"\"\"Only transform responses for the OpenAPI spec path.\"\"\"\n        return (\n            all(\n                re.match(expr, val)\n                for expr, val in [\n                    (self.openapi_spec_path, request.url.path),\n                    (\n                        self.json_content_type_expr,\n                        Headers(scope=scope).get(\"content-type\", \"\"),\n                    ),\n                ]\n            )\n            and 200 &lt;= scope[\"status\"] &lt; 300\n        )\n\n    def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n        \"\"\"Augment the OpenAPI spec with auth information.\"\"\"\n        # Remove any existing servers field from upstream API\n        # This ensures we don't have conflicting server declarations\n        if \"servers\" in data:\n            del data[\"servers\"]\n\n        # Add servers field with root path if root_path is set\n        if self.root_path:\n            data[\"servers\"] = [{\"url\": self.root_path}]\n\n        # Add security scheme\n        components = ensure_type(data, \"components\", dict)\n        securitySchemes = ensure_type(components, \"securitySchemes\", dict)\n        securitySchemes[self.auth_scheme_name] = self.auth_scheme_override or {\n            \"type\": \"openIdConnect\",\n            \"openIdConnectUrl\": self.oidc_discovery_url,\n        }\n\n        # Add security to private endpoints\n        for path, method_config in data[\"paths\"].items():\n            for method, config in method_config.items():\n                if method == \"options\":\n                    # OPTIONS requests are not authenticated, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n                    continue\n                match = find_match(\n                    path,\n                    method,\n                    self.private_endpoints,\n                    self.public_endpoints,\n                    self.default_public,\n                )\n                if match.is_private:\n                    security = ensure_type(config, \"security\", list)\n                    security.append({self.auth_scheme_name: match.required_scopes})\n        return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/UpdateOpenApiMiddleware/#stac_auth_proxy.middleware.UpdateOpenApiMiddleware.OpenApiMiddleware.should_transform_response","title":"<code>should_transform_response(request: Request, scope: Scope) -&gt; bool</code>","text":"<p>Only transform responses for the OpenAPI spec path.</p> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n    \"\"\"Only transform responses for the OpenAPI spec path.\"\"\"\n    return (\n        all(\n            re.match(expr, val)\n            for expr, val in [\n                (self.openapi_spec_path, request.url.path),\n                (\n                    self.json_content_type_expr,\n                    Headers(scope=scope).get(\"content-type\", \"\"),\n                ),\n            ]\n        )\n        and 200 &lt;= scope[\"status\"] &lt; 300\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/UpdateOpenApiMiddleware/#stac_auth_proxy.middleware.UpdateOpenApiMiddleware.OpenApiMiddleware.transform_json","title":"<code>transform_json(data: dict[str, Any], request: Request) -&gt; dict[str, Any]</code>","text":"<p>Augment the OpenAPI spec with auth information.</p> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n    \"\"\"Augment the OpenAPI spec with auth information.\"\"\"\n    # Remove any existing servers field from upstream API\n    # This ensures we don't have conflicting server declarations\n    if \"servers\" in data:\n        del data[\"servers\"]\n\n    # Add servers field with root path if root_path is set\n    if self.root_path:\n        data[\"servers\"] = [{\"url\": self.root_path}]\n\n    # Add security scheme\n    components = ensure_type(data, \"components\", dict)\n    securitySchemes = ensure_type(components, \"securitySchemes\", dict)\n    securitySchemes[self.auth_scheme_name] = self.auth_scheme_override or {\n        \"type\": \"openIdConnect\",\n        \"openIdConnectUrl\": self.oidc_discovery_url,\n    }\n\n    # Add security to private endpoints\n    for path, method_config in data[\"paths\"].items():\n        for method, config in method_config.items():\n            if method == \"options\":\n                # OPTIONS requests are not authenticated, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n                continue\n            match = find_match(\n                path,\n                method,\n                self.private_endpoints,\n                self.public_endpoints,\n                self.default_public,\n            )\n            if match.is_private:\n                security = ensure_type(config, \"security\", list)\n                security.append({self.auth_scheme_name: match.required_scopes})\n    return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/","title":"stac_auth_proxy.middleware","text":"<p>Custom middleware.</p>"},{"location":"reference/stac_auth_proxy/middleware/#stac_auth_proxy.middleware.OpenApiMiddleware","title":"<code>OpenApiMiddleware</code>  <code>dataclass</code>","text":"<p>               Bases: <code>JsonResponseMiddleware</code></p> <p>Middleware to add the OpenAPI spec to the response.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Callable[list, Awaitable[None]]</code> required <code>openapi_spec_path</code> <code>str</code> required <code>oidc_discovery_url</code> <code>str</code> required <code>private_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>public_endpoints</code> <code>dict[str, Sequence[Literal[GET, POST, PUT, DELETE, PATCH]]]</code> required <code>default_public</code> <code>bool</code> required <code>root_path</code> <code>str</code> <code>''</code> <code>auth_scheme_name</code> <code>str</code> <code>'oidcAuth'</code> <code>auth_scheme_override</code> <code>dict | None</code> <code>None</code> <code>json_content_type_expr</code> <code>str</code> <code>'application/(vnd\\\\.oai\\\\.openapi\\\\+json?|json)'</code> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>@dataclass(frozen=True)\nclass OpenApiMiddleware(JsonResponseMiddleware):\n    \"\"\"Middleware to add the OpenAPI spec to the response.\"\"\"\n\n    app: ASGIApp\n    openapi_spec_path: str\n    oidc_discovery_url: str\n    private_endpoints: EndpointMethods\n    public_endpoints: EndpointMethods\n    default_public: bool\n    root_path: str = \"\"\n    auth_scheme_name: str = \"oidcAuth\"\n    auth_scheme_override: Optional[dict] = None\n\n    json_content_type_expr: str = r\"application/(vnd\\.oai\\.openapi\\+json?|json)\"\n\n    def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n        \"\"\"Only transform responses for the OpenAPI spec path.\"\"\"\n        return (\n            all(\n                re.match(expr, val)\n                for expr, val in [\n                    (self.openapi_spec_path, request.url.path),\n                    (\n                        self.json_content_type_expr,\n                        Headers(scope=scope).get(\"content-type\", \"\"),\n                    ),\n                ]\n            )\n            and 200 &lt;= scope[\"status\"] &lt; 300\n        )\n\n    def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n        \"\"\"Augment the OpenAPI spec with auth information.\"\"\"\n        # Remove any existing servers field from upstream API\n        # This ensures we don't have conflicting server declarations\n        if \"servers\" in data:\n            del data[\"servers\"]\n\n        # Add servers field with root path if root_path is set\n        if self.root_path:\n            data[\"servers\"] = [{\"url\": self.root_path}]\n\n        # Add security scheme\n        components = ensure_type(data, \"components\", dict)\n        securitySchemes = ensure_type(components, \"securitySchemes\", dict)\n        securitySchemes[self.auth_scheme_name] = self.auth_scheme_override or {\n            \"type\": \"openIdConnect\",\n            \"openIdConnectUrl\": self.oidc_discovery_url,\n        }\n\n        # Add security to private endpoints\n        for path, method_config in data[\"paths\"].items():\n            for method, config in method_config.items():\n                if method == \"options\":\n                    # OPTIONS requests are not authenticated, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n                    continue\n                match = find_match(\n                    path,\n                    method,\n                    self.private_endpoints,\n                    self.public_endpoints,\n                    self.default_public,\n                )\n                if match.is_private:\n                    security = ensure_type(config, \"security\", list)\n                    security.append({self.auth_scheme_name: match.required_scopes})\n        return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/#stac_auth_proxy.middleware.OpenApiMiddleware.should_transform_response","title":"<code>should_transform_response(request: Request, scope: Scope) -&gt; bool</code>","text":"<p>Only transform responses for the OpenAPI spec path.</p> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>def should_transform_response(self, request: Request, scope: Scope) -&gt; bool:\n    \"\"\"Only transform responses for the OpenAPI spec path.\"\"\"\n    return (\n        all(\n            re.match(expr, val)\n            for expr, val in [\n                (self.openapi_spec_path, request.url.path),\n                (\n                    self.json_content_type_expr,\n                    Headers(scope=scope).get(\"content-type\", \"\"),\n                ),\n            ]\n        )\n        and 200 &lt;= scope[\"status\"] &lt; 300\n    )\n</code></pre>"},{"location":"reference/stac_auth_proxy/middleware/#stac_auth_proxy.middleware.OpenApiMiddleware.transform_json","title":"<code>transform_json(data: dict[str, Any], request: Request) -&gt; dict[str, Any]</code>","text":"<p>Augment the OpenAPI spec with auth information.</p> Source code in <code>src/stac_auth_proxy/middleware/UpdateOpenApiMiddleware.py</code> <pre><code>def transform_json(self, data: dict[str, Any], request: Request) -&gt; dict[str, Any]:\n    \"\"\"Augment the OpenAPI spec with auth information.\"\"\"\n    # Remove any existing servers field from upstream API\n    # This ensures we don't have conflicting server declarations\n    if \"servers\" in data:\n        del data[\"servers\"]\n\n    # Add servers field with root path if root_path is set\n    if self.root_path:\n        data[\"servers\"] = [{\"url\": self.root_path}]\n\n    # Add security scheme\n    components = ensure_type(data, \"components\", dict)\n    securitySchemes = ensure_type(components, \"securitySchemes\", dict)\n    securitySchemes[self.auth_scheme_name] = self.auth_scheme_override or {\n        \"type\": \"openIdConnect\",\n        \"openIdConnectUrl\": self.oidc_discovery_url,\n    }\n\n    # Add security to private endpoints\n    for path, method_config in data[\"paths\"].items():\n        for method, config in method_config.items():\n            if method == \"options\":\n                # OPTIONS requests are not authenticated, https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\n                continue\n            match = find_match(\n                path,\n                method,\n                self.private_endpoints,\n                self.public_endpoints,\n                self.default_public,\n            )\n            if match.is_private:\n                security = ensure_type(config, \"security\", list)\n                security.append({self.auth_scheme_name: match.required_scopes})\n    return data\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/","title":"stac_auth_proxy.utils","text":"<p>Utils module for stac_auth_proxy.</p>"},{"location":"reference/stac_auth_proxy/utils/cache/","title":"stac_auth_proxy.utils.cache","text":"<p>Cache utilities.</p>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.MemoryCache","title":"<code>MemoryCache</code>  <code>dataclass</code>","text":"<p>Cache results of a method call for a given key.</p> <p>Parameters:</p> Name Type Description Default <code>ttl</code> <code>float</code> <code>5.0</code> <code>cache</code> <code>dict[tuple[Any], tuple[Any, float]]</code> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> <code>&lt;class 'dict'&gt;</code> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>@dataclass\nclass MemoryCache:\n    \"\"\"Cache results of a method call for a given key.\"\"\"\n\n    ttl: float = 5.0\n    cache: dict[tuple[Any], tuple[Any, float]] = field(default_factory=dict)\n    _last_pruned: float = field(default_factory=time)\n\n    def __getitem__(self, key: Any) -&gt; Any:\n        \"\"\"Get a value from the cache if it is not expired.\"\"\"\n        if key not in self.cache:\n            msg = f\"{self._key_str(key)!r} not in cache.\"\n            logger.debug(msg)\n            raise KeyError(msg)\n\n        result, timestamp = self.cache[key]\n        if (time() - timestamp) &gt; self.ttl:\n            msg = f\"{self._key_str(key)!r} in cache, but expired.\"\n            del self.cache[key]\n            logger.debug(msg)\n            raise KeyError(f\"{key} expired\")\n\n        logger.debug(f\"{self._key_str(key)} in cache, returning cached result.\")\n        return result\n\n    def __setitem__(self, key: Any, value: Any):\n        \"\"\"Set a value in the cache.\"\"\"\n        self.cache[key] = (value, time())\n        self._prune()\n\n    def __contains__(self, key: Any) -&gt; bool:\n        \"\"\"Check if a key is in the cache and is not expired.\"\"\"\n        try:\n            self[key]\n            return True\n        except KeyError:\n            return False\n\n    def get(self, key: Any) -&gt; Any:\n        \"\"\"Get a value from the cache.\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return None\n\n    def _prune(self):\n        \"\"\"Prune the cache of expired items.\"\"\"\n        if time() - self._last_pruned &lt; self.ttl:\n            return\n        self.cache = {\n            k: (v, time_entered)\n            for k, (v, time_entered) in self.cache.items()\n            if time_entered &gt; (time() - self.ttl)\n        }\n        self._last_pruned = time()\n\n    @staticmethod\n    def _key_str(key: Any) -&gt; str:\n        \"\"\"Get a string representation of a key.\"\"\"\n        return key if len(str(key)) &lt; 10 else f\"{str(key)[:9]}...\"\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.MemoryCache.__contains__","title":"<code>__contains__(key: Any) -&gt; bool</code>","text":"<p>Check if a key is in the cache and is not expired.</p> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>def __contains__(self, key: Any) -&gt; bool:\n    \"\"\"Check if a key is in the cache and is not expired.\"\"\"\n    try:\n        self[key]\n        return True\n    except KeyError:\n        return False\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.MemoryCache.__getitem__","title":"<code>__getitem__(key: Any) -&gt; Any</code>","text":"<p>Get a value from the cache if it is not expired.</p> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Any:\n    \"\"\"Get a value from the cache if it is not expired.\"\"\"\n    if key not in self.cache:\n        msg = f\"{self._key_str(key)!r} not in cache.\"\n        logger.debug(msg)\n        raise KeyError(msg)\n\n    result, timestamp = self.cache[key]\n    if (time() - timestamp) &gt; self.ttl:\n        msg = f\"{self._key_str(key)!r} in cache, but expired.\"\n        del self.cache[key]\n        logger.debug(msg)\n        raise KeyError(f\"{key} expired\")\n\n    logger.debug(f\"{self._key_str(key)} in cache, returning cached result.\")\n    return result\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.MemoryCache.__setitem__","title":"<code>__setitem__(key: Any, value: Any)</code>","text":"<p>Set a value in the cache.</p> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>def __setitem__(self, key: Any, value: Any):\n    \"\"\"Set a value in the cache.\"\"\"\n    self.cache[key] = (value, time())\n    self._prune()\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.MemoryCache.get","title":"<code>get(key: Any) -&gt; Any</code>","text":"<p>Get a value from the cache.</p> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>def get(self, key: Any) -&gt; Any:\n    \"\"\"Get a value from the cache.\"\"\"\n    try:\n        return self[key]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/cache/#stac_auth_proxy.utils.cache.get_value_by_path","title":"<code>get_value_by_path(obj: dict, path: str, default: Any = None) -&gt; Any</code>","text":"<p>Get a value from a dictionary using dot notation.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict</code> <p>The dictionary to search in</p> required <code>path</code> <code>str</code> <p>The dot notation path (e.g. \"payload.sub\")</p> required <code>default</code> <code>Any</code> <p>Default value to return if path doesn't exist</p> <code>None</code> <pre><code>The value at the specified path or default if path doesn't exist\n</code></pre> Source code in <code>src/stac_auth_proxy/utils/cache.py</code> <pre><code>def get_value_by_path(obj: dict, path: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a value from a dictionary using dot notation.\n\n    Args:\n        obj: The dictionary to search in\n        path: The dot notation path (e.g. \"payload.sub\")\n        default: Default value to return if path doesn't exist\n\n    Returns:\n    -------\n        The value at the specified path or default if path doesn't exist\n\n    \"\"\"\n    try:\n        for key in path.split(\".\"):\n            if obj is None:\n                return default\n            obj = obj.get(key, default)\n        return obj\n    except (AttributeError, KeyError, TypeError):\n        return default\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/filters/","title":"stac_auth_proxy.utils.filters","text":"<p>Utility functions.</p>"},{"location":"reference/stac_auth_proxy/utils/filters/#stac_auth_proxy.utils.filters.append_body_filter","title":"<code>append_body_filter(body: dict, filter: Expr, filter_lang: Optional[str] = None) -&gt; dict</code>","text":"<p>Insert a filter expression into a request body. If a filter already exists, combine them.</p> Source code in <code>src/stac_auth_proxy/utils/filters.py</code> <pre><code>def append_body_filter(\n    body: dict, filter: Expr, filter_lang: Optional[str] = None\n) -&gt; dict:\n    \"\"\"Insert a filter expression into a request body. If a filter already exists, combine them.\"\"\"\n    cur_filter = body.get(\"filter\")\n    filter_lang = filter_lang or body.get(\"filter-lang\", \"cql2-json\")\n    if cur_filter:\n        filter = filter + Expr(cur_filter)\n    return {\n        **body,\n        \"filter\": filter.to_text() if filter_lang == \"cql2-text\" else filter.to_json(),\n        \"filter-lang\": filter_lang,\n    }\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/filters/#stac_auth_proxy.utils.filters.append_qs_filter","title":"<code>append_qs_filter(qs: str, filter: Expr, filter_lang: Optional[str] = None) -&gt; bytes</code>","text":"<p>Insert a filter expression into a query string. If a filter already exists, combine them.</p> Source code in <code>src/stac_auth_proxy/utils/filters.py</code> <pre><code>def append_qs_filter(qs: str, filter: Expr, filter_lang: Optional[str] = None) -&gt; bytes:\n    \"\"\"Insert a filter expression into a query string. If a filter already exists, combine them.\"\"\"\n    qs_dict = {k: v[0] for k, v in parse_qs(qs).items()}\n    new_qs_dict = append_body_filter(\n        qs_dict, filter, filter_lang or qs_dict.get(\"filter-lang\", \"cql2-text\")\n    )\n    return dict_to_query_string(new_qs_dict).encode(\"utf-8\")\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/filters/#stac_auth_proxy.utils.filters.dict_to_query_string","title":"<code>dict_to_query_string(params: dict) -&gt; str</code>","text":"<p>Convert a dictionary to a query string. Dict values are converted to JSON strings, unlike the default behavior of urllib.parse.urlencode.</p> Source code in <code>src/stac_auth_proxy/utils/filters.py</code> <pre><code>def dict_to_query_string(params: dict) -&gt; str:\n    \"\"\"\n    Convert a dictionary to a query string. Dict values are converted to JSON strings,\n    unlike the default behavior of urllib.parse.urlencode.\n    \"\"\"\n    parts = []\n    for key, val in params.items():\n        if isinstance(val, (dict, list)):\n            val = json.dumps(val, separators=(\",\", \":\"))\n        parts.append(f\"{key}={val}\")\n    return \"&amp;\".join(parts)\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/middleware/","title":"stac_auth_proxy.utils.middleware","text":"<p>Utilities for middleware response handling.</p>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.JsonResponseMiddleware","title":"<code>JsonResponseMiddleware</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for middleware that transforms JSON response bodies.</p> Source code in <code>src/stac_auth_proxy/utils/middleware.py</code> <pre><code>class JsonResponseMiddleware(ABC):\n    \"\"\"Base class for middleware that transforms JSON response bodies.\"\"\"\n\n    app: ASGIApp\n\n    # Expected data type for JSON responses. Only responses matching this type will be transformed.\n    # If None, all JSON responses will be transformed regardless of type.\n    expected_data_type: Optional[type] = dict\n\n    @abstractmethod\n    def should_transform_response(\n        self, request: Request, scope: Scope\n    ) -&gt; bool:  # mypy: ignore\n        \"\"\"\n        Determine if this response should be transformed. At a minimum, this\n        should check the request's path and content type.\n\n        Returns\n        -------\n            bool: True if the response should be transformed\n\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transform_json(self, data: Any, request: Request) -&gt; Any:\n        \"\"\"\n        Transform the JSON data.\n\n        Args:\n            data: The parsed JSON data\n            request: The HTTP request object\n\n        Returns:\n        -------\n            The transformed JSON data\n\n        \"\"\"\n        ...\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        \"\"\"Process the request/response.\"\"\"\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        start_message: Optional[Message] = None\n        body = b\"\"\n\n        async def transform_response(message: Message) -&gt; None:\n            nonlocal start_message\n            nonlocal body\n\n            start_message = start_message or message\n            headers = MutableHeaders(scope=start_message)\n            request = Request(scope)\n\n            if not self.should_transform_response(\n                request=request,\n                scope=start_message,\n            ):\n                # For non-JSON responses, send the start message immediately\n                await send(message)\n                return\n\n            # Delay sending start message until we've processed the body\n            if message[\"type\"] == \"http.response.start\":\n                return\n\n            body += message[\"body\"]\n\n            # Skip body chunks until all chunks have been received\n            if message.get(\"more_body\"):\n                return\n\n            # Transform the JSON body\n            if body:\n                try:\n                    data = json.loads(body)\n                except json.JSONDecodeError as e:\n                    logger.error(\"Error parsing JSON: %s\", e)\n                    logger.error(\"Body: %s\", body)\n                    logger.error(\"Response scope: %s\", scope)\n                    response = JSONResponse(\n                        {\"error\": \"Received invalid JSON from upstream server\"},\n                        status_code=502,\n                    )\n                    await response(scope, receive, send)\n                    return\n\n                if self.expected_data_type is None or isinstance(\n                    data, self.expected_data_type\n                ):\n                    transformed = self.transform_json(data, request=request)\n                    body = json.dumps(transformed).encode()\n                else:\n                    logger.warning(\n                        \"Received JSON response with unexpected data type %r from upstream server (%r %r), \"\n                        \"skipping transformation (expected: %r)\",\n                        type(data).__name__,\n                        request.method,\n                        request.url,\n                        self.expected_data_type.__name__,\n                    )\n\n            # Update content-length header\n            headers[\"content-length\"] = str(len(body))\n            start_message[\"headers\"] = [\n                (key.encode(), value.encode()) for key, value in headers.items()\n            ]\n\n            # Send response\n            await send(start_message)\n            await send(\n                {\n                    \"type\": \"http.response.body\",\n                    \"body\": body,\n                    \"more_body\": False,\n                }\n            )\n\n        return await self.app(scope, receive, transform_response)\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.JsonResponseMiddleware.__call__","title":"<code>__call__(scope: Scope, receive: Receive, send: Send) -&gt; None</code>  <code>async</code>","text":"<p>Process the request/response.</p> Source code in <code>src/stac_auth_proxy/utils/middleware.py</code> <pre><code>async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n    \"\"\"Process the request/response.\"\"\"\n    if scope[\"type\"] != \"http\":\n        return await self.app(scope, receive, send)\n\n    start_message: Optional[Message] = None\n    body = b\"\"\n\n    async def transform_response(message: Message) -&gt; None:\n        nonlocal start_message\n        nonlocal body\n\n        start_message = start_message or message\n        headers = MutableHeaders(scope=start_message)\n        request = Request(scope)\n\n        if not self.should_transform_response(\n            request=request,\n            scope=start_message,\n        ):\n            # For non-JSON responses, send the start message immediately\n            await send(message)\n            return\n\n        # Delay sending start message until we've processed the body\n        if message[\"type\"] == \"http.response.start\":\n            return\n\n        body += message[\"body\"]\n\n        # Skip body chunks until all chunks have been received\n        if message.get(\"more_body\"):\n            return\n\n        # Transform the JSON body\n        if body:\n            try:\n                data = json.loads(body)\n            except json.JSONDecodeError as e:\n                logger.error(\"Error parsing JSON: %s\", e)\n                logger.error(\"Body: %s\", body)\n                logger.error(\"Response scope: %s\", scope)\n                response = JSONResponse(\n                    {\"error\": \"Received invalid JSON from upstream server\"},\n                    status_code=502,\n                )\n                await response(scope, receive, send)\n                return\n\n            if self.expected_data_type is None or isinstance(\n                data, self.expected_data_type\n            ):\n                transformed = self.transform_json(data, request=request)\n                body = json.dumps(transformed).encode()\n            else:\n                logger.warning(\n                    \"Received JSON response with unexpected data type %r from upstream server (%r %r), \"\n                    \"skipping transformation (expected: %r)\",\n                    type(data).__name__,\n                    request.method,\n                    request.url,\n                    self.expected_data_type.__name__,\n                )\n\n        # Update content-length header\n        headers[\"content-length\"] = str(len(body))\n        start_message[\"headers\"] = [\n            (key.encode(), value.encode()) for key, value in headers.items()\n        ]\n\n        # Send response\n        await send(start_message)\n        await send(\n            {\n                \"type\": \"http.response.body\",\n                \"body\": body,\n                \"more_body\": False,\n            }\n        )\n\n    return await self.app(scope, receive, transform_response)\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.JsonResponseMiddleware.should_transform_response","title":"<code>should_transform_response(request: Request, scope: Scope) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Determine if this response should be transformed. At a minimum, this should check the request's path and content type.</p>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.JsonResponseMiddleware.should_transform_response--returns","title":"Returns","text":"<pre><code>bool: True if the response should be transformed\n</code></pre> Source code in <code>src/stac_auth_proxy/utils/middleware.py</code> <pre><code>@abstractmethod\ndef should_transform_response(\n    self, request: Request, scope: Scope\n) -&gt; bool:  # mypy: ignore\n    \"\"\"\n    Determine if this response should be transformed. At a minimum, this\n    should check the request's path and content type.\n\n    Returns\n    -------\n        bool: True if the response should be transformed\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.JsonResponseMiddleware.transform_json","title":"<code>transform_json(data: Any, request: Request) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Transform the JSON data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The parsed JSON data</p> required <code>request</code> <code>Request</code> <p>The HTTP request object</p> required <pre><code>The transformed JSON data\n</code></pre> Source code in <code>src/stac_auth_proxy/utils/middleware.py</code> <pre><code>@abstractmethod\ndef transform_json(self, data: Any, request: Request) -&gt; Any:\n    \"\"\"\n    Transform the JSON data.\n\n    Args:\n        data: The parsed JSON data\n        request: The HTTP request object\n\n    Returns:\n    -------\n        The transformed JSON data\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/middleware/#stac_auth_proxy.utils.middleware.required_conformance","title":"<code>required_conformance(*conformances: str, attr_name: str = '__required_conformances__')</code>","text":"<p>Register required conformance classes with a middleware class.</p> Source code in <code>src/stac_auth_proxy/utils/middleware.py</code> <pre><code>def required_conformance(\n    *conformances: str,\n    attr_name: str = \"__required_conformances__\",\n):\n    \"\"\"Register required conformance classes with a middleware class.\"\"\"\n\n    def decorator(middleware):\n        setattr(middleware, attr_name, list(conformances))\n        return middleware\n\n    return decorator\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/","title":"stac_auth_proxy.utils.requests","text":"<p>Utility functions for working with HTTP requests.</p>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.MatchResult","title":"<code>MatchResult</code>  <code>dataclass</code>","text":"<p>Result of a match between a path and method and a set of endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>is_private</code> <code>bool</code> required <code>required_scopes</code> <code>Sequence[str]</code> <p>Built-in mutable sequence.</p> <p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p> <code>&lt;dynamic&gt;</code> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>@dataclass\nclass MatchResult:\n    \"\"\"Result of a match between a path and method and a set of endpoints.\"\"\"\n\n    is_private: bool\n    required_scopes: Sequence[str] = field(default_factory=list)\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.build_server_timing_header","title":"<code>build_server_timing_header(current_value: Optional[str] = None, *, name: str, desc: str, dur: float)</code>","text":"<p>Append a timing header to headers.</p> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def build_server_timing_header(\n    current_value: Optional[str] = None, *, name: str, desc: str, dur: float\n):\n    \"\"\"Append a timing header to headers.\"\"\"\n    metric = f'{name};desc=\"{desc}\";dur={dur:.3f}'\n    if current_value:\n        return f\"{current_value}, {metric}\"\n    return metric\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.dict_to_bytes","title":"<code>dict_to_bytes(d: dict) -&gt; bytes</code>","text":"<p>Convert a dictionary to a body.</p> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def dict_to_bytes(d: dict) -&gt; bytes:\n    \"\"\"Convert a dictionary to a body.\"\"\"\n    return json.dumps(d, separators=(\",\", \":\")).encode(\"utf-8\")\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.extract_variables","title":"<code>extract_variables(url: str) -&gt; dict</code>","text":"<p>Extract variables from a URL path. Being that we use a catch-all endpoint for the proxy, we can't rely on the path parameters that FastAPI provides.</p> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def extract_variables(url: str) -&gt; dict:\n    \"\"\"\n    Extract variables from a URL path. Being that we use a catch-all endpoint for the proxy,\n    we can't rely on the path parameters that FastAPI provides.\n    \"\"\"\n    path = urlparse(url).path\n    # This allows either /items or /bulk_items, with an optional item_id following.\n    pattern = r\"^/collections/(?P&lt;collection_id&gt;[^/]+)(?:/(?:items|bulk_items)(?:/(?P&lt;item_id&gt;[^/]+))?)?/?$\"\n    match = re.match(pattern, path)\n    return {k: v for k, v in match.groupdict().items() if v} if match else {}\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.find_match","title":"<code>find_match(path: str, method: str, private_endpoints: EndpointMethods, public_endpoints: EndpointMethods, default_public: bool) -&gt; MatchResult</code>","text":"<p>Check if the given path and method match any of the regex patterns and methods in the endpoints.</p> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def find_match(\n    path: str,\n    method: str,\n    private_endpoints: EndpointMethods,\n    public_endpoints: EndpointMethods,\n    default_public: bool,\n) -&gt; \"MatchResult\":\n    \"\"\"Check if the given path and method match any of the regex patterns and methods in the endpoints.\"\"\"\n    primary_endpoints = private_endpoints if default_public else public_endpoints\n    matched, required_scopes = _check_endpoint_match(path, method, primary_endpoints)\n    if matched:\n        return MatchResult(\n            is_private=default_public,\n            required_scopes=required_scopes,\n        )\n\n    # If default_public and no match found in private_endpoints, it's public\n    if default_public:\n        return MatchResult(is_private=False)\n\n    # If not default_public, check private_endpoints for required scopes\n    matched, required_scopes = _check_endpoint_match(path, method, private_endpoints)\n    if matched:\n        return MatchResult(is_private=True, required_scopes=required_scopes)\n\n    # Default case: if not default_public and no explicit match, it's private\n    return MatchResult(is_private=True)\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.get_base_url","title":"<code>get_base_url(request: Request) -&gt; str</code>","text":"<p>Get the request's base URL, accounting for forwarded headers from load balancers/proxies.</p> <p>This function handles both the standard Forwarded header (RFC 7239) and legacy X-Forwarded-* headers to reconstruct the original client URL when the service is deployed behind load balancers or reverse proxies.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The Starlette request object</p> required <p>Returns:</p> Type Description <code>str</code> <p>The reconstructed client base URL</p> Example Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def get_base_url(request: Request) -&gt; str:\n    \"\"\"\n    Get the request's base URL, accounting for forwarded headers from load balancers/proxies.\n\n    This function handles both the standard Forwarded header (RFC 7239) and legacy\n    X-Forwarded-* headers to reconstruct the original client URL when the service\n    is deployed behind load balancers or reverse proxies.\n\n    Args:\n        request: The Starlette request object\n\n    Returns:\n        The reconstructed client base URL\n\n    Example:\n        &gt;&gt;&gt; # With Forwarded header\n        &gt;&gt;&gt; request.headers = {\"Forwarded\": \"for=192.0.2.43; proto=https; host=api.example.com\"}\n        &gt;&gt;&gt; get_base_url(request)\n        \"https://api.example.com/\"\n\n        &gt;&gt;&gt; # With X-Forwarded-* headers\n        &gt;&gt;&gt; request.headers = {\"X-Forwarded-Host\": \"api.example.com\", \"X-Forwarded-Proto\": \"https\"}\n        &gt;&gt;&gt; get_base_url(request)\n        \"https://api.example.com/\"\n\n    \"\"\"\n    # Check for standard Forwarded header first (RFC 7239)\n    forwarded_header = request.headers.get(\"Forwarded\")\n    if forwarded_header:\n        try:\n            forwarded_info = parse_forwarded_header(forwarded_header)\n            # Only use Forwarded header if we successfully parsed it and got useful info\n            if forwarded_info and (\n                \"proto\" in forwarded_info or \"host\" in forwarded_info\n            ):\n                scheme = forwarded_info.get(\"proto\", request.url.scheme)\n                host = forwarded_info.get(\"host\", request.url.netloc)\n                # Note: Forwarded header doesn't include path, so we use request.base_url.path\n                path = request.base_url.path\n                return f\"{scheme}://{host}{path}\"\n        except Exception as e:\n            logger.warning(f\"Failed to parse Forwarded header: {e}\")\n\n    # Fall back to legacy X-Forwarded-* headers\n    forwarded_host = request.headers.get(\"X-Forwarded-Host\")\n    forwarded_proto = request.headers.get(\"X-Forwarded-Proto\")\n    forwarded_path = request.headers.get(\"X-Forwarded-Path\")\n\n    if forwarded_host:\n        # Use forwarded headers to reconstruct the original client URL\n        scheme = forwarded_proto or request.url.scheme\n        netloc = forwarded_host\n        # Use forwarded path if available, otherwise use request base URL path\n        path = forwarded_path or request.base_url.path\n    else:\n        # Fall back to the request's base URL if no forwarded headers\n        scheme = request.url.scheme\n        netloc = request.url.netloc\n        path = request.base_url.path\n\n    return f\"{scheme}://{netloc}{path}\"\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.get_base_url--with-forwarded-header","title":"With Forwarded header","text":"<p>request.headers = {\"Forwarded\": \"for=192.0.2.43; proto=https; host=api.example.com\"} get_base_url(request) \"api.example.com/\"</p>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.get_base_url--with-x-forwarded-headers","title":"With X-Forwarded-* headers","text":"<p>request.headers = {\"X-Forwarded-Host\": \"api.example.com\", \"X-Forwarded-Proto\": \"https\"} get_base_url(request) \"api.example.com/\"</p>"},{"location":"reference/stac_auth_proxy/utils/requests/#stac_auth_proxy.utils.requests.parse_forwarded_header","title":"<code>parse_forwarded_header(forwarded_header: str) -&gt; Dict[str, str]</code>","text":"<p>Parse the Forwarded header according to RFC 7239.</p> <p>Parameters:</p> Name Type Description Default <code>forwarded_header</code> <code>str</code> <p>The Forwarded header value</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary containing parsed forwarded information (proto, host, for, by, etc.)</p> Example <p>parse_forwarded_header(\"for=192.0.2.43; by=203.0.113.60; proto=https; host=api.example.com\")</p> Source code in <code>src/stac_auth_proxy/utils/requests.py</code> <pre><code>def parse_forwarded_header(forwarded_header: str) -&gt; Dict[str, str]:\n    \"\"\"\n    Parse the Forwarded header according to RFC 7239.\n\n    Args:\n        forwarded_header: The Forwarded header value\n\n    Returns:\n        Dictionary containing parsed forwarded information (proto, host, for, by, etc.)\n\n    Example:\n        &gt;&gt;&gt; parse_forwarded_header(\"for=192.0.2.43; by=203.0.113.60; proto=https; host=api.example.com\")\n        {'for': '192.0.2.43', 'by': '203.0.113.60', 'proto': 'https', 'host': 'api.example.com'}\n\n    \"\"\"\n    # Forwarded header format: \"for=192.0.2.43, for=198.51.100.17; by=203.0.113.60; proto=https; host=example.com\"\n    # The format is: for=value1, for=value2; by=value; proto=value; host=value\n    # We need to parse all the key=value pairs, taking the first 'for' value\n    forwarded_info = {}\n\n    try:\n        # Parse all key=value pairs separated by semicolons\n        for pair in forwarded_header.split(\";\"):\n            pair = pair.strip()\n            if \"=\" in pair:\n                key, value = pair.split(\"=\", 1)\n                key = key.strip()\n                value = value.strip().strip('\"')\n\n                # For 'for' field, only take the first value if there are multiple\n                if key == \"for\" and key not in forwarded_info:\n                    # Extract the first for value (before comma if present)\n                    first_for_value = value.split(\",\")[0].strip()\n                    forwarded_info[key] = first_for_value\n                elif key != \"for\":\n                    # For other fields, just use the value as-is\n                    forwarded_info[key] = value\n    except Exception as e:\n        logger.warning(f\"Failed to parse Forwarded header '{forwarded_header}': {e}\")\n        return {}\n\n    return forwarded_info\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/stac/","title":"stac_auth_proxy.utils.stac","text":"<p>STAC-specific utilities.</p>"},{"location":"reference/stac_auth_proxy/utils/stac/#stac_auth_proxy.utils.stac.ensure_type","title":"<code>ensure_type(data: dict[str, Any], key: str, expected_type: type[T], default_factory: Callable[[], T] | None = None) -&gt; T</code>","text":"<p>Ensure a dictionary value conforms to the expected type.</p> <p>If the value doesn't exist or is not an instance of the expected type, it will be replaced with the default value from default_factory.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dictionary containing the value</p> required <code>key</code> <code>str</code> <p>The key to check</p> required <code>expected_type</code> <code>type[T]</code> <p>The expected type class</p> required <code>default_factory</code> <code>Callable[[], T] | None</code> <p>Optional callable that returns the default value. If not provided, expected_type will be called with no arguments.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>The value from the dictionary if it's the correct type, otherwise the default value</p> Example <p>data = {\"stac_extensions\": None} extensions = ensure_type(data, \"stac_extensions\", list)</p> Source code in <code>src/stac_auth_proxy/utils/stac.py</code> <pre><code>def ensure_type(\n    data: dict[str, Any],\n    key: str,\n    expected_type: type[T],\n    default_factory: Callable[[], T] | None = None,\n) -&gt; T:\n    \"\"\"\n    Ensure a dictionary value conforms to the expected type.\n\n    If the value doesn't exist or is not an instance of the expected type,\n    it will be replaced with the default value from default_factory.\n\n    Args:\n        data: The dictionary containing the value\n        key: The key to check\n        expected_type: The expected type class\n        default_factory: Optional callable that returns the default value.\n            If not provided, expected_type will be called with no arguments.\n\n    Returns:\n        The value from the dictionary if it's the correct type, otherwise the default value\n\n    Example:\n        &gt;&gt;&gt; data = {\"stac_extensions\": None}\n        &gt;&gt;&gt; extensions = ensure_type(data, \"stac_extensions\", list)\n        &gt;&gt;&gt; # extensions is now [] and data[\"stac_extensions\"] is []\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = {\"items\": \"invalid\"}\n        &gt;&gt;&gt; items = ensure_type(data, \"items\", list, lambda: [\"default\"])\n        &gt;&gt;&gt; # items is now [\"default\"] with custom factory\n\n    \"\"\"\n    value = data.get(key)\n    if not isinstance(value, expected_type):\n        if value is not None:\n            logger.warning(\n                \"Field '%s' expected %s but got %s: %r\",\n                key,\n                expected_type.__name__,\n                type(value).__name__,\n                value,\n            )\n        factory = default_factory if default_factory is not None else expected_type\n        value = factory()\n        data[key] = value\n    return value\n</code></pre>"},{"location":"reference/stac_auth_proxy/utils/stac/#stac_auth_proxy.utils.stac.ensure_type--extensions-is-now-and-datastac_extensions-is","title":"extensions is now [] and data[\"stac_extensions\"] is []","text":"<p>data = {\"items\": \"invalid\"} items = ensure_type(data, \"items\", list, lambda: [\"default\"])</p>"},{"location":"reference/stac_auth_proxy/utils/stac/#stac_auth_proxy.utils.stac.ensure_type--items-is-now-default-with-custom-factory","title":"items is now [\"default\"] with custom factory","text":""},{"location":"reference/stac_auth_proxy/utils/stac/#stac_auth_proxy.utils.stac.get_links","title":"<code>get_links(data: dict) -&gt; chain[dict]</code>","text":"<p>Get all links from a STAC response.</p> Source code in <code>src/stac_auth_proxy/utils/stac.py</code> <pre><code>def get_links(data: dict) -&gt; chain[dict]:\n    \"\"\"Get all links from a STAC response.\"\"\"\n    return chain(\n        # Item/Collection\n        data.get(\"links\", []),\n        # Collections/Items/Search\n        (\n            link\n            for prop in [\"features\", \"collections\"]\n            for object_with_links in data.get(prop, [])\n            for link in object_with_links.get(\"links\", [])\n        ),\n    )\n</code></pre>"}]}